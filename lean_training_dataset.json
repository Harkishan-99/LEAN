[
  {
    "prompt": "Design a momentum strategy that trades META, AMZN, PEP based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"META\", \"AMZN\", \"PEP\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades MSFT, NFLX, ADBE, PG, PYPL, CRM based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"MSFT\", \"NFLX\", \"ADBE\", \"PG\", \"PYPL\", \"CRM\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades CSCO, BAC, GOOGL, JNJ based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"CSCO\", \"BAC\", \"GOOGL\", \"JNJ\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades KO, CSCO, MSFT, QQQ, PEP, AAPL based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"KO\", \"CSCO\", \"MSFT\", \"QQQ\", \"PEP\", \"AAPL\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for AAPL with 15-period and 2.0 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 15, 2.0)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades CRM, AMD, NVDA, GOOGL, V based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"CRM\", \"AMD\", \"NVDA\", \"GOOGL\", \"V\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 10-day and 24-day SMAs. Trade JPM with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 10)\n        self.long_sma = self.SMA(self.symbol, 24)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 10 crossed above SMA 24\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 10 crossed below SMA 24\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for NFLX with 20-period and 2.0 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"NFLX\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 20, 2.0)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for AAPL that buys when RSI < 30 and sells when RSI > 76. Use 5% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.05\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 30:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 76:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 8-day and 43-day EMAs. Trade CSCO with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"CSCO\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 8)\n        self.long_ema = self.EMA(self.symbol, 43)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 8 above EMA 43\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 8 below EMA 43\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 5-day and 45-day EMAs. Trade JNJ with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"JNJ\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 5)\n        self.long_ema = self.EMA(self.symbol, 45)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 5 above EMA 45\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 5 below EMA 45\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for CSCO that buys when RSI < 21 and sells when RSI > 67. Use 20% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"CSCO\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.2\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 21:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 67:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 14-day and 28-day SMAs. Trade PEP with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 14)\n        self.long_sma = self.SMA(self.symbol, 28)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 14 crossed above SMA 28\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 14 crossed below SMA 28\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for CRM that buys when RSI < 25 and sells when RSI > 67. Use 20% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"CRM\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.2\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 25:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 67:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades AMD, INTC, BAC based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"AMD\", \"INTC\", \"BAC\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for KO that buys when RSI < 21 and sells when RSI > 80. Use 10% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.1\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 21:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 80:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for NVDA with 15-period and 2.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"NVDA\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 15, 2.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades PG, V, JPM, MA, CRM, SPY based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"PG\", \"V\", \"JPM\", \"MA\", \"CRM\", \"SPY\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades PG, ADBE, BAC, QQQ, INTC, CSCO based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"PG\", \"ADBE\", \"BAC\", \"QQQ\", \"INTC\", \"CSCO\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades BAC, KO, WMT based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"BAC\", \"KO\", \"WMT\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 11-day and 22-day SMAs. Trade INTC with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"INTC\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 11)\n        self.long_sma = self.SMA(self.symbol, 22)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 11 crossed above SMA 22\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 11 crossed below SMA 22\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Design a momentum strategy that trades TSLA, PEP, QQQ, NVDA, BAC based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"TSLA\", \"PEP\", \"QQQ\", \"NVDA\", \"BAC\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 9-day and 35-day SMAs. Trade JPM with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 9)\n        self.long_sma = self.SMA(self.symbol, 35)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 9 crossed above SMA 35\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 9 crossed below SMA 35\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Design a momentum strategy that trades MSFT, NFLX, QQQ, JPM based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"MSFT\", \"NFLX\", \"QQQ\", \"JPM\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 10-day and 22-day EMAs. Trade QQQ with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"QQQ\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 10)\n        self.long_ema = self.EMA(self.symbol, 22)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 10 above EMA 22\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 10 below EMA 22\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 5-day and 32-day SMAs. Trade TSLA with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"TSLA\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 5)\n        self.long_sma = self.SMA(self.symbol, 32)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 5 crossed above SMA 32\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 5 crossed below SMA 32\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades INTC, CRM, NVDA, QQQ, MA, V based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"INTC\", \"CRM\", \"NVDA\", \"QQQ\", \"MA\", \"V\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 9-day and 33-day SMAs. Trade KO with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 9)\n        self.long_sma = self.SMA(self.symbol, 33)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 9 crossed above SMA 33\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 9 crossed below SMA 33\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a EMA crossover strategy using 7-day and 46-day EMAs. Trade PYPL with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PYPL\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 7)\n        self.long_ema = self.EMA(self.symbol, 46)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 7 above EMA 46\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 7 below EMA 46\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 12-day and 20-day EMAs. Trade CRM with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"CRM\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 12)\n        self.long_ema = self.EMA(self.symbol, 20)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 12 above EMA 20\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 12 below EMA 20\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 7-day and 35-day SMAs. Trade PEP with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 7)\n        self.long_sma = self.SMA(self.symbol, 35)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 7 crossed above SMA 35\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 7 crossed below SMA 35\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a SMA crossover strategy using 13-day and 22-day SMAs. Trade V with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"V\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 13)\n        self.long_sma = self.SMA(self.symbol, 22)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 13 crossed above SMA 22\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 13 crossed below SMA 22\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Design a momentum strategy that trades MA, ADBE, QQQ based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"MA\", \"ADBE\", \"QQQ\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 10-day and 47-day EMAs. Trade MSFT with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 10)\n        self.long_ema = self.EMA(self.symbol, 47)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 10 above EMA 47\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 10 below EMA 47\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for PG that buys when RSI < 31 and sells when RSI > 65. Use 10% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PG\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.1\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 31:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades QQQ, MA, V, JNJ based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"QQQ\", \"MA\", \"V\", \"JNJ\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades WMT, NFLX, JNJ, AMD, INTC based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"WMT\", \"NFLX\", \"JNJ\", \"AMD\", \"INTC\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades MSFT, JNJ, SPY, WMT, NVDA, AAPL based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"MSFT\", \"JNJ\", \"SPY\", \"WMT\", \"NVDA\", \"AAPL\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 5-day and 45-day EMAs. Trade BAC with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 5)\n        self.long_ema = self.EMA(self.symbol, 45)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 5 above EMA 45\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 5 below EMA 45\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 13-day and 23-day SMAs. Trade QQQ with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"QQQ\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 13)\n        self.long_sma = self.SMA(self.symbol, 23)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 13 crossed above SMA 23\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 13 crossed below SMA 23\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for TSLA that buys when RSI < 32 and sells when RSI > 70. Use 15% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"TSLA\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.15\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 32:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 70:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades SPY, TSLA, MSFT, KO based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"SPY\", \"TSLA\", \"MSFT\", \"KO\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades QQQ, NFLX, JPM, INTC, SPY based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"QQQ\", \"NFLX\", \"JPM\", \"INTC\", \"SPY\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 13-day and 33-day SMAs. Trade CRM with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"CRM\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 13)\n        self.long_sma = self.SMA(self.symbol, 33)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 13 crossed above SMA 33\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 13 crossed below SMA 33\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a SMA crossover strategy using 8-day and 23-day SMAs. Trade AAPL with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 8)\n        self.long_sma = self.SMA(self.symbol, 23)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 8 crossed above SMA 23\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 8 crossed below SMA 23\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Design a momentum strategy that trades META, JNJ, QQQ, ADBE based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"META\", \"JNJ\", \"QQQ\", \"ADBE\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for MSFT with 20-period and 2.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 20, 2.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades META, CSCO, V, BAC, INTC, PYPL based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"META\", \"CSCO\", \"V\", \"BAC\", \"INTC\", \"PYPL\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 9-day and 43-day SMAs. Trade INTC with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"INTC\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 9)\n        self.long_sma = self.SMA(self.symbol, 43)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 9 crossed above SMA 43\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 9 crossed below SMA 43\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades TSLA, AMZN, MSFT, AAPL, WMT based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"TSLA\", \"AMZN\", \"MSFT\", \"AAPL\", \"WMT\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for KO with 15-period and 2.0 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 15, 2.0)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades CRM, META, BAC, PEP based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"CRM\", \"META\", \"BAC\", \"PEP\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades INTC, PYPL, META based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"INTC\", \"PYPL\", \"META\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for CRM that buys when RSI < 27 and sells when RSI > 80. Use 15% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"CRM\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.15\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 27:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 80:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for GOOGL with 25-period and 1.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 25, 1.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for KO with 15-period and 1.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 15, 1.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 15-day and 36-day EMAs. Trade AMD with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AMD\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 15)\n        self.long_ema = self.EMA(self.symbol, 36)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 15 above EMA 36\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 15 below EMA 36\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for META with 20-period and 1.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 20, 1.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 7-day and 42-day EMAs. Trade PG with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PG\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 7)\n        self.long_ema = self.EMA(self.symbol, 42)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 7 above EMA 42\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 7 below EMA 42\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 9-day and 34-day SMAs. Trade WMT with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"WMT\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 9)\n        self.long_sma = self.SMA(self.symbol, 34)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 9 crossed above SMA 34\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 9 crossed below SMA 34\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Design a momentum strategy that trades GOOGL, KO, JPM, AMD, V, PG based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"GOOGL\", \"KO\", \"JPM\", \"AMD\", \"V\", \"PG\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades TSLA, PEP, JPM, PYPL, KO, V based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"TSLA\", \"PEP\", \"JPM\", \"PYPL\", \"KO\", \"V\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 7-day and 21-day EMAs. Trade CSCO with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"CSCO\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 7)\n        self.long_ema = self.EMA(self.symbol, 21)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 7 above EMA 21\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 7 below EMA 21\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 5-day and 29-day SMAs. Trade QQQ with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"QQQ\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 5)\n        self.long_sma = self.SMA(self.symbol, 29)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 5 crossed above SMA 29\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 5 crossed below SMA 29\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 9-day and 20-day EMAs. Trade AMZN with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AMZN\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 9)\n        self.long_ema = self.EMA(self.symbol, 20)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 9 above EMA 20\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 9 below EMA 20\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 7-day and 21-day SMAs. Trade MSFT with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 7)\n        self.long_sma = self.SMA(self.symbol, 21)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 7 crossed above SMA 21\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 7 crossed below SMA 21\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Design a momentum strategy that trades META, BAC, QQQ, CRM, KO, GOOGL based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"META\", \"BAC\", \"QQQ\", \"CRM\", \"KO\", \"GOOGL\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades SPY, BAC, JNJ based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"SPY\", \"BAC\", \"JNJ\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for AMZN with 20-period and 2.0 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AMZN\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 20, 2.0)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 9-day and 45-day SMAs. Trade SPY with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"SPY\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 9)\n        self.long_sma = self.SMA(self.symbol, 45)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 9 crossed above SMA 45\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 9 crossed below SMA 45\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Design a momentum strategy that trades AAPL, QQQ, NFLX based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"AAPL\", \"QQQ\", \"NFLX\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades PG, AAPL, SPY, JPM, NVDA based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"PG\", \"AAPL\", \"SPY\", \"JPM\", \"NVDA\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 14-day and 25-day EMAs. Trade CSCO with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"CSCO\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 14)\n        self.long_ema = self.EMA(self.symbol, 25)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 14 above EMA 25\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 14 below EMA 25\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 9-day and 36-day SMAs. Trade GOOGL with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 9)\n        self.long_sma = self.SMA(self.symbol, 36)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 9 crossed above SMA 36\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 9 crossed below SMA 36\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Design a momentum strategy that trades NVDA, V, INTC, CRM, KO based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"NVDA\", \"V\", \"INTC\", \"CRM\", \"KO\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades KO, JPM, GOOGL, SPY based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"KO\", \"JPM\", \"GOOGL\", \"SPY\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 15-day and 24-day SMAs. Trade PEP with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 15)\n        self.long_sma = self.SMA(self.symbol, 24)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 15 crossed above SMA 24\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 15 crossed below SMA 24\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Design a momentum strategy that trades ADBE, TSLA, SPY, AAPL based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"ADBE\", \"TSLA\", \"SPY\", \"AAPL\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 8-day and 22-day SMAs. Trade AAPL with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 8)\n        self.long_sma = self.SMA(self.symbol, 22)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 8 crossed above SMA 22\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 8 crossed below SMA 22\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Design a momentum strategy that trades PEP, PYPL, SPY, AAPL based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"PEP\", \"PYPL\", \"SPY\", \"AAPL\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 5-day and 50-day SMAs. Trade AMD with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AMD\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 5)\n        self.long_sma = self.SMA(self.symbol, 50)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 5 crossed above SMA 50\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 5 crossed below SMA 50\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades AMD, INTC, GOOGL, META, JNJ, SPY based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"AMD\", \"INTC\", \"GOOGL\", \"META\", \"JNJ\", \"SPY\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 6-day and 32-day SMAs. Trade CSCO with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"CSCO\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 6)\n        self.long_sma = self.SMA(self.symbol, 32)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 6 crossed above SMA 32\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 6 crossed below SMA 32\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Design a momentum strategy that trades AMZN, QQQ, WMT, JNJ based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"AMZN\", \"QQQ\", \"WMT\", \"JNJ\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 9-day and 30-day SMAs. Trade CRM with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"CRM\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 9)\n        self.long_sma = self.SMA(self.symbol, 30)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 9 crossed above SMA 30\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 9 crossed below SMA 30\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Design a momentum strategy that trades KO, PG, PEP, CRM based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"KO\", \"PG\", \"PEP\", \"CRM\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for JNJ that buys when RSI < 34 and sells when RSI > 70. Use 10% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"JNJ\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.1\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 34:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 70:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades NFLX, NVDA, CRM, MSFT, ADBE, PG based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"NFLX\", \"NVDA\", \"CRM\", \"MSFT\", \"ADBE\", \"PG\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 12-day and 30-day SMAs. Trade INTC with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"INTC\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 12)\n        self.long_sma = self.SMA(self.symbol, 30)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 12 crossed above SMA 30\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 12 crossed below SMA 30\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for QQQ that buys when RSI < 22 and sells when RSI > 71. Use 15% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"QQQ\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.15\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 22:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 71:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for CSCO that buys when RSI < 22 and sells when RSI > 70. Use 20% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"CSCO\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.2\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 22:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 70:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades KO, WMT, AMZN based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"KO\", \"WMT\", \"AMZN\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for AMD that buys when RSI < 21 and sells when RSI > 68. Use 20% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AMD\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.2\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 21:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 68:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 5-day and 50-day EMAs. Trade BAC with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 5)\n        self.long_ema = self.EMA(self.symbol, 50)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 5 above EMA 50\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 5 below EMA 50\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for NVDA with 15-period and 2.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"NVDA\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 15, 2.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades TSLA, MA, PYPL based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"TSLA\", \"MA\", \"PYPL\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for MA that buys when RSI < 34 and sells when RSI > 75. Use 10% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MA\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.1\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 34:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 75:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for PYPL that buys when RSI < 31 and sells when RSI > 78. Use 5% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PYPL\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.05\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 31:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 78:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 13-day and 31-day EMAs. Trade META with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 13)\n        self.long_ema = self.EMA(self.symbol, 31)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 13 above EMA 31\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 13 below EMA 31\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 14-day and 33-day SMAs. Trade AAPL with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 14)\n        self.long_sma = self.SMA(self.symbol, 33)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 14 crossed above SMA 33\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 14 crossed below SMA 33\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Design a momentum strategy that trades JNJ, PYPL, KO, JPM based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"JNJ\", \"PYPL\", \"KO\", \"JPM\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades JNJ, CSCO, WMT, AAPL based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"JNJ\", \"CSCO\", \"WMT\", \"AAPL\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 14-day and 25-day EMAs. Trade MA with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MA\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 14)\n        self.long_ema = self.EMA(self.symbol, 25)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 14 above EMA 25\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 14 below EMA 25\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for JNJ with 25-period and 1.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"JNJ\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 25, 1.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades NFLX, AMD, CRM, JPM, MSFT, PG based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"NFLX\", \"AMD\", \"CRM\", \"JPM\", \"MSFT\", \"PG\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 15-day and 35-day EMAs. Trade JNJ with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"JNJ\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 15)\n        self.long_ema = self.EMA(self.symbol, 35)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 15 above EMA 35\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 15 below EMA 35\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 8-day and 28-day SMAs. Trade AAPL with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 8)\n        self.long_sma = self.SMA(self.symbol, 28)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 8 crossed above SMA 28\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 8 crossed below SMA 28\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a SMA crossover strategy using 11-day and 21-day SMAs. Trade KO with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 11)\n        self.long_sma = self.SMA(self.symbol, 21)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 11 crossed above SMA 21\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 11 crossed below SMA 21\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 10-day and 29-day SMAs. Trade CRM with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"CRM\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 10)\n        self.long_sma = self.SMA(self.symbol, 29)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 10 crossed above SMA 29\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 10 crossed below SMA 29\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for CRM that buys when RSI < 29 and sells when RSI > 75. Use 20% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"CRM\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.2\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 29:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 75:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 8-day and 36-day SMAs. Trade WMT with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"WMT\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 8)\n        self.long_sma = self.SMA(self.symbol, 36)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 8 crossed above SMA 36\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 8 crossed below SMA 36\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a EMA crossover strategy using 15-day and 40-day EMAs. Trade AAPL with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 15)\n        self.long_ema = self.EMA(self.symbol, 40)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 15 above EMA 40\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 15 below EMA 40\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 15-day and 24-day SMAs. Trade SPY with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"SPY\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 15)\n        self.long_sma = self.SMA(self.symbol, 24)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 15 crossed above SMA 24\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 15 crossed below SMA 24\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a EMA crossover strategy using 7-day and 20-day EMAs. Trade ADBE with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"ADBE\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 7)\n        self.long_ema = self.EMA(self.symbol, 20)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 7 above EMA 20\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 7 below EMA 20\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 15-day and 28-day SMAs. Trade NVDA with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"NVDA\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 15)\n        self.long_sma = self.SMA(self.symbol, 28)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 15 crossed above SMA 28\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 15 crossed below SMA 28\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a SMA crossover strategy using 5-day and 30-day SMAs. Trade MA with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MA\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 5)\n        self.long_sma = self.SMA(self.symbol, 30)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 5 crossed above SMA 30\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 5 crossed below SMA 30\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for NFLX that buys when RSI < 27 and sells when RSI > 73. Use 10% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"NFLX\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.1\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 27:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 73:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 12-day and 29-day SMAs. Trade GOOGL with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 12)\n        self.long_sma = self.SMA(self.symbol, 29)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 12 crossed above SMA 29\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 12 crossed below SMA 29\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades PG, PYPL, AMZN based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"PG\", \"PYPL\", \"AMZN\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 10-day and 39-day SMAs. Trade WMT with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"WMT\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 10)\n        self.long_sma = self.SMA(self.symbol, 39)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 10 crossed above SMA 39\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 10 crossed below SMA 39\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 10-day and 28-day EMAs. Trade AMD with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AMD\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 10)\n        self.long_ema = self.EMA(self.symbol, 28)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 10 above EMA 28\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 10 below EMA 28\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for PG with 20-period and 1.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PG\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 20, 1.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades INTC, WMT, JPM, ADBE based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"INTC\", \"WMT\", \"JPM\", \"ADBE\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for QQQ that buys when RSI < 26 and sells when RSI > 75. Use 20% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"QQQ\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.2\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 26:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 75:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for MSFT that buys when RSI < 31 and sells when RSI > 74. Use 15% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.15\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 31:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 74:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 9-day and 23-day EMAs. Trade KO with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 9)\n        self.long_ema = self.EMA(self.symbol, 23)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 9 above EMA 23\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 9 below EMA 23\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 13-day and 24-day SMAs. Trade V with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"V\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 13)\n        self.long_sma = self.SMA(self.symbol, 24)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 13 crossed above SMA 24\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 13 crossed below SMA 24\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a EMA crossover strategy using 7-day and 31-day EMAs. Trade AAPL with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 7)\n        self.long_ema = self.EMA(self.symbol, 31)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 7 above EMA 31\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 7 below EMA 31\")"
  },
  {
    "prompt": "Design a momentum strategy that trades INTC, JNJ, NFLX, AMZN based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"INTC\", \"JNJ\", \"NFLX\", \"AMZN\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades META, CSCO, AMZN, JNJ, CRM, NFLX based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"META\", \"CSCO\", \"AMZN\", \"JNJ\", \"CRM\", \"NFLX\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for PEP that buys when RSI < 23 and sells when RSI > 73. Use 10% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.1\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 23:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 73:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades NVDA, CSCO, CRM based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"NVDA\", \"CSCO\", \"CRM\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades JNJ, CRM, WMT based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"JNJ\", \"CRM\", \"WMT\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 15-day and 39-day SMAs. Trade MSFT with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 15)\n        self.long_sma = self.SMA(self.symbol, 39)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 15 crossed above SMA 39\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 15 crossed below SMA 39\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for JNJ with 25-period and 2.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"JNJ\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 25, 2.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 8-day and 35-day SMAs. Trade AMZN with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AMZN\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 8)\n        self.long_sma = self.SMA(self.symbol, 35)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 8 crossed above SMA 35\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 8 crossed below SMA 35\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a EMA crossover strategy using 14-day and 46-day EMAs. Trade PEP with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 14)\n        self.long_ema = self.EMA(self.symbol, 46)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 14 above EMA 46\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 14 below EMA 46\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for NFLX that buys when RSI < 22 and sells when RSI > 78. Use 10% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"NFLX\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.1\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 22:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 78:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 13-day and 29-day SMAs. Trade SPY with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"SPY\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 13)\n        self.long_sma = self.SMA(self.symbol, 29)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 13 crossed above SMA 29\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 13 crossed below SMA 29\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Design a momentum strategy that trades V, QQQ, PEP, MA, KO based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"V\", \"QQQ\", \"PEP\", \"MA\", \"KO\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 10-day and 24-day EMAs. Trade CSCO with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"CSCO\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 10)\n        self.long_ema = self.EMA(self.symbol, 24)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 10 above EMA 24\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 10 below EMA 24\")"
  },
  {
    "prompt": "Design a momentum strategy that trades MSFT, V, INTC, BAC, AMZN, GOOGL based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"MSFT\", \"V\", \"INTC\", \"BAC\", \"AMZN\", \"GOOGL\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades V, PEP, JNJ, SPY, KO, MA based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"V\", \"PEP\", \"JNJ\", \"SPY\", \"KO\", \"MA\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades MSFT, MA, INTC, NFLX based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"MSFT\", \"MA\", \"INTC\", \"NFLX\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades BAC, KO, GOOGL based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"BAC\", \"KO\", \"GOOGL\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades V, GOOGL, NFLX, ADBE based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"V\", \"GOOGL\", \"NFLX\", \"ADBE\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 5-day and 43-day EMAs. Trade AAPL with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 5)\n        self.long_ema = self.EMA(self.symbol, 43)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 5 above EMA 43\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 5 below EMA 43\")"
  },
  {
    "prompt": "Design a momentum strategy that trades V, JPM, SPY based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"V\", \"JPM\", \"SPY\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 8-day and 21-day EMAs. Trade JNJ with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"JNJ\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 8)\n        self.long_ema = self.EMA(self.symbol, 21)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 8 above EMA 21\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 8 below EMA 21\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for CSCO that buys when RSI < 34 and sells when RSI > 79. Use 5% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"CSCO\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.05\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 34:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 79:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades AMD, GOOGL, KO, INTC, PG based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"AMD\", \"GOOGL\", \"KO\", \"INTC\", \"PG\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for MSFT that buys when RSI < 22 and sells when RSI > 73. Use 5% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.05\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 22:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 73:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for AMZN with 15-period and 2.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AMZN\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 15, 2.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for NFLX with 15-period and 2.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"NFLX\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 15, 2.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for AAPL with 25-period and 1.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 25, 1.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades NVDA, SPY, CSCO, TSLA based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"NVDA\", \"SPY\", \"CSCO\", \"TSLA\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades WMT, PYPL, CRM, QQQ based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"WMT\", \"PYPL\", \"CRM\", \"QQQ\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades GOOGL, INTC, AMD, AAPL based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"GOOGL\", \"INTC\", \"AMD\", \"AAPL\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 5-day and 35-day SMAs. Trade PYPL with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PYPL\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 5)\n        self.long_sma = self.SMA(self.symbol, 35)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 5 crossed above SMA 35\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 5 crossed below SMA 35\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades NFLX, AMZN, ADBE, AMD, PEP based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"NFLX\", \"AMZN\", \"ADBE\", \"AMD\", \"PEP\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades PYPL, WMT, INTC, NFLX, V, NVDA based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"PYPL\", \"WMT\", \"INTC\", \"NFLX\", \"V\", \"NVDA\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 6-day and 37-day SMAs. Trade AAPL with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 6)\n        self.long_sma = self.SMA(self.symbol, 37)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 6 crossed above SMA 37\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 6 crossed below SMA 37\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for KO that buys when RSI < 35 and sells when RSI > 66. Use 20% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.2\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 66:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 5-day and 21-day SMAs. Trade TSLA with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"TSLA\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 5)\n        self.long_sma = self.SMA(self.symbol, 21)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 5 crossed above SMA 21\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 5 crossed below SMA 21\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 8-day and 35-day EMAs. Trade TSLA with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"TSLA\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 8)\n        self.long_ema = self.EMA(self.symbol, 35)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 8 above EMA 35\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 8 below EMA 35\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for JPM with 25-period and 1.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 25, 1.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades KO, JNJ, SPY, ADBE, CSCO, PG based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"KO\", \"JNJ\", \"SPY\", \"ADBE\", \"CSCO\", \"PG\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 13-day and 31-day EMAs. Trade NVDA with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"NVDA\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 13)\n        self.long_ema = self.EMA(self.symbol, 31)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 13 above EMA 31\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 13 below EMA 31\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 11-day and 21-day SMAs. Trade MA with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MA\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 11)\n        self.long_sma = self.SMA(self.symbol, 21)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 11 crossed above SMA 21\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 11 crossed below SMA 21\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a SMA crossover strategy using 6-day and 30-day SMAs. Trade PEP with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 6)\n        self.long_sma = self.SMA(self.symbol, 30)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 6 crossed above SMA 30\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 6 crossed below SMA 30\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Design a momentum strategy that trades INTC, JPM, AAPL, AMD, PYPL based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"INTC\", \"JPM\", \"AAPL\", \"AMD\", \"PYPL\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 14-day and 44-day SMAs. Trade AAPL with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 14)\n        self.long_sma = self.SMA(self.symbol, 44)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 14 crossed above SMA 44\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 14 crossed below SMA 44\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a EMA crossover strategy using 10-day and 42-day EMAs. Trade AAPL with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 10)\n        self.long_ema = self.EMA(self.symbol, 42)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 10 above EMA 42\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 10 below EMA 42\")"
  },
  {
    "prompt": "Design a momentum strategy that trades JPM, CRM, BAC, AMZN based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"JPM\", \"CRM\", \"BAC\", \"AMZN\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades V, INTC, NFLX, JPM, SPY, MSFT based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"V\", \"INTC\", \"NFLX\", \"JPM\", \"SPY\", \"MSFT\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades PEP, AMD, MA, BAC, PYPL based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"PEP\", \"AMD\", \"MA\", \"BAC\", \"PYPL\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 7-day and 31-day SMAs. Trade GOOGL with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 7)\n        self.long_sma = self.SMA(self.symbol, 31)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 7 crossed above SMA 31\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 7 crossed below SMA 31\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a SMA crossover strategy using 12-day and 32-day SMAs. Trade PYPL with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PYPL\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 12)\n        self.long_sma = self.SMA(self.symbol, 32)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 12 crossed above SMA 32\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 12 crossed below SMA 32\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades CRM, JPM, INTC, AAPL based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"CRM\", \"JPM\", \"INTC\", \"AAPL\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades NFLX, MSFT, JPM, SPY, AAPL based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"NFLX\", \"MSFT\", \"JPM\", \"SPY\", \"AAPL\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 14-day and 36-day SMAs. Trade INTC with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"INTC\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 14)\n        self.long_sma = self.SMA(self.symbol, 36)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 14 crossed above SMA 36\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 14 crossed below SMA 36\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a EMA crossover strategy using 7-day and 38-day EMAs. Trade KO with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 7)\n        self.long_ema = self.EMA(self.symbol, 38)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 7 above EMA 38\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 7 below EMA 38\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades QQQ, AMD, CRM, NFLX, WMT, JNJ based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"QQQ\", \"AMD\", \"CRM\", \"NFLX\", \"WMT\", \"JNJ\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades JNJ, PYPL, JPM based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"JNJ\", \"PYPL\", \"JPM\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades MSFT, INTC, WMT, CSCO, SPY, V based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"MSFT\", \"INTC\", \"WMT\", \"CSCO\", \"SPY\", \"V\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 5-day and 40-day SMAs. Trade NFLX with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"NFLX\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 5)\n        self.long_sma = self.SMA(self.symbol, 40)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 5 crossed above SMA 40\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 5 crossed below SMA 40\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Design a momentum strategy that trades PYPL, TSLA, PEP, AAPL, MSFT, AMZN based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"PYPL\", \"TSLA\", \"PEP\", \"AAPL\", \"MSFT\", \"AMZN\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 12-day and 38-day EMAs. Trade QQQ with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"QQQ\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 12)\n        self.long_ema = self.EMA(self.symbol, 38)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 12 above EMA 38\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 12 below EMA 38\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 11-day and 44-day SMAs. Trade PYPL with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PYPL\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 11)\n        self.long_sma = self.SMA(self.symbol, 44)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 11 crossed above SMA 44\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 11 crossed below SMA 44\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Design a momentum strategy that trades JNJ, V, SPY, MA based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"JNJ\", \"V\", \"SPY\", \"MA\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for NVDA with 20-period and 1.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"NVDA\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 20, 1.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades BAC, V, MSFT, JNJ, SPY based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"BAC\", \"V\", \"MSFT\", \"JNJ\", \"SPY\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades AMZN, BAC, WMT, TSLA based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"AMZN\", \"BAC\", \"WMT\", \"TSLA\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades TSLA, PEP, KO, MSFT, AAPL, MA based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"TSLA\", \"PEP\", \"KO\", \"MSFT\", \"AAPL\", \"MA\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for GOOGL with 15-period and 1.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 15, 1.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 11-day and 31-day SMAs. Trade META with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 11)\n        self.long_sma = self.SMA(self.symbol, 31)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 11 crossed above SMA 31\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 11 crossed below SMA 31\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for PEP that buys when RSI < 29 and sells when RSI > 77. Use 20% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.2\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 29:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 77:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy with 20-period and 2 standard deviations. Trade MSFT with RSI confirmation.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 20, 2)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 8-day and 41-day SMAs. Trade MA with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MA\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 8)\n        self.long_sma = self.SMA(self.symbol, 41)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 8 crossed above SMA 41\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 8 crossed below SMA 41\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for MA with 25-period and 1.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MA\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 25, 1.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades TSLA, PYPL, V, KO, GOOGL, MA based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"TSLA\", \"PYPL\", \"V\", \"KO\", \"GOOGL\", \"MA\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for KO with 20-period and 1.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 20, 1.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades TSLA, JPM, AMZN, SPY based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"TSLA\", \"JPM\", \"AMZN\", \"SPY\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a simple moving average crossover strategy using 10-day and 20-day SMAs. Trade SPY with $100,000 starting capital from 2020 to 2023.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"SPY\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 10)\n        self.long_sma = self.SMA(self.symbol, 20)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 10 crossed above SMA 20\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 10 crossed below SMA 20\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a EMA crossover strategy using 6-day and 36-day EMAs. Trade KO with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 6)\n        self.long_ema = self.EMA(self.symbol, 36)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 6 above EMA 36\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 6 below EMA 36\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 7-day and 27-day SMAs. Trade NVDA with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"NVDA\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 7)\n        self.long_sma = self.SMA(self.symbol, 27)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 7 crossed above SMA 27\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 7 crossed below SMA 27\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for QQQ with 25-period and 2.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"QQQ\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 25, 2.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build an EMA crossover strategy with 12-day and 26-day EMAs for AAPL. Use daily resolution and $50,000 initial capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 12)\n        self.long_ema = self.EMA(self.symbol, 26)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 12 above EMA 26\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 12 below EMA 26\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 12-day and 44-day EMAs. Trade KO with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 12)\n        self.long_ema = self.EMA(self.symbol, 44)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 12 above EMA 44\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 12 below EMA 44\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 14-day and 22-day SMAs. Trade CSCO with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"CSCO\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 14)\n        self.long_sma = self.SMA(self.symbol, 22)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 14 crossed above SMA 22\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 14 crossed below SMA 22\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for TSLA with 15-period and 2.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"TSLA\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 15, 2.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades META, BAC, CSCO, PYPL, MA, V based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"META\", \"BAC\", \"CSCO\", \"PYPL\", \"MA\", \"V\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades JPM, TSLA, GOOGL, NFLX, V, ADBE based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"JPM\", \"TSLA\", \"GOOGL\", \"NFLX\", \"V\", \"ADBE\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 6-day and 25-day EMAs. Trade INTC with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"INTC\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 6)\n        self.long_ema = self.EMA(self.symbol, 25)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 6 above EMA 25\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 6 below EMA 25\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 5-day and 32-day EMAs. Trade JPM with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 5)\n        self.long_ema = self.EMA(self.symbol, 32)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 5 above EMA 32\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 5 below EMA 32\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 13-day and 35-day SMAs. Trade JNJ with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"JNJ\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 13)\n        self.long_sma = self.SMA(self.symbol, 35)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 13 crossed above SMA 35\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 13 crossed below SMA 35\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 9-day and 32-day EMAs. Trade PYPL with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PYPL\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 9)\n        self.long_ema = self.EMA(self.symbol, 32)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 9 above EMA 32\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 9 below EMA 32\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades ADBE, MSFT, MA based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"ADBE\", \"MSFT\", \"MA\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades PG, GOOGL, AAPL, SPY, NFLX based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"PG\", \"GOOGL\", \"AAPL\", \"SPY\", \"NFLX\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades AAPL, CSCO, MSFT based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"AAPL\", \"CSCO\", \"MSFT\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades MA, NVDA, BAC based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"MA\", \"NVDA\", \"BAC\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades CSCO, PG, V, QQQ, NVDA, MSFT based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"CSCO\", \"PG\", \"V\", \"QQQ\", \"NVDA\", \"MSFT\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades META, V, INTC, ADBE, CRM based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"META\", \"V\", \"INTC\", \"ADBE\", \"CRM\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for NFLX that buys when RSI < 34 and sells when RSI > 66. Use 15% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"NFLX\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.15\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 34:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 66:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for AAPL with 25-period and 1.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 25, 1.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for PYPL with 15-period and 2.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PYPL\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 15, 2.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades JPM, JNJ, META based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"JPM\", \"JNJ\", \"META\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades NVDA, MA, BAC based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"NVDA\", \"MA\", \"BAC\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for NFLX that buys when RSI < 33 and sells when RSI > 74. Use 20% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"NFLX\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.2\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 33:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 74:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 15-day and 27-day EMAs. Trade JPM with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 15)\n        self.long_ema = self.EMA(self.symbol, 27)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 15 above EMA 27\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 15 below EMA 27\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 6-day and 30-day SMAs. Trade PG with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PG\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 6)\n        self.long_sma = self.SMA(self.symbol, 30)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 6 crossed above SMA 30\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 6 crossed below SMA 30\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for MA with 20-period and 1.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MA\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 20, 1.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for PYPL that buys when RSI < 26 and sells when RSI > 68. Use 15% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PYPL\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.15\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 26:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 68:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for KO that buys when RSI < 31 and sells when RSI > 73. Use 10% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.1\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 31:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 73:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 12-day and 31-day EMAs. Trade PG with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PG\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 12)\n        self.long_ema = self.EMA(self.symbol, 31)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 12 above EMA 31\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 12 below EMA 31\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for META with 20-period and 1.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 20, 1.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 15-day and 25-day SMAs. Trade AMZN with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AMZN\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 15)\n        self.long_sma = self.SMA(self.symbol, 25)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 15 crossed above SMA 25\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 15 crossed below SMA 25\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a EMA crossover strategy using 5-day and 39-day EMAs. Trade MA with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MA\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 5)\n        self.long_ema = self.EMA(self.symbol, 39)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 5 above EMA 39\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 5 below EMA 39\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades AMZN, PG, ADBE, MSFT based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"AMZN\", \"PG\", \"ADBE\", \"MSFT\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for JNJ that buys when RSI < 29 and sells when RSI > 68. Use 15% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"JNJ\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.15\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 29:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 68:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades GOOGL, PYPL, META, KO based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"GOOGL\", \"PYPL\", \"META\", \"KO\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for PG that buys when RSI < 28 and sells when RSI > 71. Use 15% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PG\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.15\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 28:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 71:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 11-day and 39-day EMAs. Trade AMZN with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AMZN\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 11)\n        self.long_ema = self.EMA(self.symbol, 39)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 11 above EMA 39\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 11 below EMA 39\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades MA, GOOGL, ADBE, V based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"MA\", \"GOOGL\", \"ADBE\", \"V\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades PG, WMT, QQQ, PEP based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"PG\", \"WMT\", \"QQQ\", \"PEP\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 11-day and 32-day EMAs. Trade AMD with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AMD\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 11)\n        self.long_ema = self.EMA(self.symbol, 32)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 11 above EMA 32\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 11 below EMA 32\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 14-day and 27-day EMAs. Trade MA with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MA\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 14)\n        self.long_ema = self.EMA(self.symbol, 27)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 14 above EMA 27\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 14 below EMA 27\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 12-day and 26-day SMAs. Trade MSFT with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 12)\n        self.long_sma = self.SMA(self.symbol, 26)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 12 crossed above SMA 26\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 12 crossed below SMA 26\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for NVDA that buys when RSI < 29 and sells when RSI > 79. Use 15% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"NVDA\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.15\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 29:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 79:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for SPY that buys when RSI < 31 and sells when RSI > 69. Use 5% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"SPY\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.05\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 31:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 69:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 8-day and 45-day EMAs. Trade CRM with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"CRM\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 8)\n        self.long_ema = self.EMA(self.symbol, 45)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 8 above EMA 45\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 8 below EMA 45\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 11-day and 29-day SMAs. Trade AMD with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AMD\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 11)\n        self.long_sma = self.SMA(self.symbol, 29)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 11 crossed above SMA 29\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 11 crossed below SMA 29\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Design a momentum strategy that trades WMT, CRM, TSLA, PYPL, MSFT based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"WMT\", \"CRM\", \"TSLA\", \"PYPL\", \"MSFT\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for AMD that buys when RSI < 35 and sells when RSI > 72. Use 15% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AMD\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.15\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 72:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades MSFT, AAPL, PG, AMD, META based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"MSFT\", \"AAPL\", \"PG\", \"AMD\", \"META\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 14-day and 41-day SMAs. Trade AMD with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AMD\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 14)\n        self.long_sma = self.SMA(self.symbol, 41)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 14 crossed above SMA 41\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 14 crossed below SMA 41\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades ADBE, BAC, QQQ, SPY, JNJ, GOOGL based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"ADBE\", \"BAC\", \"QQQ\", \"SPY\", \"JNJ\", \"GOOGL\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 9-day and 46-day SMAs. Trade TSLA with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"TSLA\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 9)\n        self.long_sma = self.SMA(self.symbol, 46)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 9 crossed above SMA 46\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 9 crossed below SMA 46\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for QQQ that buys when RSI < 23 and sells when RSI > 75. Use 15% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"QQQ\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.15\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 23:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 75:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for CRM that buys when RSI < 32 and sells when RSI > 69. Use 20% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"CRM\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.2\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 32:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 69:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for WMT with 25-period and 2.0 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"WMT\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 25, 2.0)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for AMZN that buys when RSI < 20 and sells when RSI > 66. Use 5% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AMZN\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.05\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 20:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 66:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 11-day and 27-day SMAs. Trade MA with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MA\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 11)\n        self.long_sma = self.SMA(self.symbol, 27)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 11 crossed above SMA 27\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 11 crossed below SMA 27\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a SMA crossover strategy using 6-day and 43-day SMAs. Trade SPY with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"SPY\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 6)\n        self.long_sma = self.SMA(self.symbol, 43)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 6 crossed above SMA 43\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 6 crossed below SMA 43\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a EMA crossover strategy using 10-day and 29-day EMAs. Trade MSFT with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 10)\n        self.long_ema = self.EMA(self.symbol, 29)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 10 above EMA 29\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 10 below EMA 29\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 12-day and 26-day EMAs. Trade ADBE with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"ADBE\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 12)\n        self.long_ema = self.EMA(self.symbol, 26)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 12 above EMA 26\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 12 below EMA 26\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 5-day and 50-day EMAs. Trade V with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"V\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 5)\n        self.long_ema = self.EMA(self.symbol, 50)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 5 above EMA 50\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 5 below EMA 50\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 14-day and 34-day EMAs. Trade JPM with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 14)\n        self.long_ema = self.EMA(self.symbol, 34)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 14 above EMA 34\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 14 below EMA 34\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 7-day and 39-day SMAs. Trade GOOGL with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 7)\n        self.long_sma = self.SMA(self.symbol, 39)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 7 crossed above SMA 39\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 7 crossed below SMA 39\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades PYPL, BAC, CSCO, GOOGL, CRM based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"PYPL\", \"BAC\", \"CSCO\", \"GOOGL\", \"CRM\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 7-day and 40-day SMAs. Trade ADBE with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"ADBE\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 7)\n        self.long_sma = self.SMA(self.symbol, 40)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 7 crossed above SMA 40\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 7 crossed below SMA 40\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a SMA crossover strategy using 6-day and 33-day SMAs. Trade KO with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 6)\n        self.long_sma = self.SMA(self.symbol, 33)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 6 crossed above SMA 33\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 6 crossed below SMA 33\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a SMA crossover strategy using 14-day and 31-day SMAs. Trade CRM with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"CRM\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 14)\n        self.long_sma = self.SMA(self.symbol, 31)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 14 crossed above SMA 31\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 14 crossed below SMA 31\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a SMA crossover strategy using 12-day and 25-day SMAs. Trade GOOGL with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 12)\n        self.long_sma = self.SMA(self.symbol, 25)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 12 crossed above SMA 25\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 12 crossed below SMA 25\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for JPM that buys when RSI < 25 and sells when RSI > 79. Use 10% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.1\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 25:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 79:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 9-day and 34-day SMAs. Trade QQQ with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"QQQ\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 9)\n        self.long_sma = self.SMA(self.symbol, 34)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 9 crossed above SMA 34\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 9 crossed below SMA 34\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades MA, V, INTC, META, AMZN based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"MA\", \"V\", \"INTC\", \"META\", \"AMZN\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 12-day and 43-day EMAs. Trade NVDA with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"NVDA\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 12)\n        self.long_ema = self.EMA(self.symbol, 43)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 12 above EMA 43\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 12 below EMA 43\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 5-day and 43-day SMAs. Trade GOOGL with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 5)\n        self.long_sma = self.SMA(self.symbol, 43)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 5 crossed above SMA 43\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 5 crossed below SMA 43\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a EMA crossover strategy using 10-day and 48-day EMAs. Trade SPY with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"SPY\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 10)\n        self.long_ema = self.EMA(self.symbol, 48)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 10 above EMA 48\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 10 below EMA 48\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 13-day and 31-day SMAs. Trade CRM with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"CRM\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 13)\n        self.long_sma = self.SMA(self.symbol, 31)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 13 crossed above SMA 31\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 13 crossed below SMA 31\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a SMA crossover strategy using 6-day and 50-day SMAs. Trade CRM with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"CRM\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 6)\n        self.long_sma = self.SMA(self.symbol, 50)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 6 crossed above SMA 50\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 6 crossed below SMA 50\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Design a momentum strategy that trades WMT, NVDA, BAC based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"WMT\", \"NVDA\", \"BAC\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades PYPL, BAC, KO based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"PYPL\", \"BAC\", \"KO\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 12-day and 35-day EMAs. Trade ADBE with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"ADBE\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 12)\n        self.long_ema = self.EMA(self.symbol, 35)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 12 above EMA 35\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 12 below EMA 35\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 14-day and 45-day SMAs. Trade PEP with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 14)\n        self.long_sma = self.SMA(self.symbol, 45)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 14 crossed above SMA 45\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 14 crossed below SMA 45\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a SMA crossover strategy using 14-day and 23-day SMAs. Trade PG with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PG\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 14)\n        self.long_sma = self.SMA(self.symbol, 23)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 14 crossed above SMA 23\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 14 crossed below SMA 23\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades PEP, META, ADBE, JPM based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"PEP\", \"META\", \"ADBE\", \"JPM\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades PG, INTC, KO, TSLA, ADBE, SPY based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"PG\", \"INTC\", \"KO\", \"TSLA\", \"ADBE\", \"SPY\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades WMT, BAC, V, CRM based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"WMT\", \"BAC\", \"V\", \"CRM\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades MSFT, AAPL, CSCO, PG, V, NVDA based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"MSFT\", \"AAPL\", \"CSCO\", \"PG\", \"V\", \"NVDA\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 8-day and 27-day EMAs. Trade V with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"V\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 8)\n        self.long_ema = self.EMA(self.symbol, 27)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 8 above EMA 27\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 8 below EMA 27\")"
  },
  {
    "prompt": "Design a momentum strategy that trades MSFT, ADBE, AMD, AMZN based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"MSFT\", \"ADBE\", \"AMD\", \"AMZN\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for TSLA that buys when RSI < 22 and sells when RSI > 77. Use 20% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"TSLA\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.2\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 22:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 77:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades WMT, SPY, CSCO, MSFT, MA, GOOGL based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"WMT\", \"SPY\", \"CSCO\", \"MSFT\", \"MA\", \"GOOGL\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 14-day and 42-day SMAs. Trade AMZN with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AMZN\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 14)\n        self.long_sma = self.SMA(self.symbol, 42)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 14 crossed above SMA 42\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 14 crossed below SMA 42\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Design a momentum strategy that trades CSCO, QQQ, KO, BAC, TSLA based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"CSCO\", \"QQQ\", \"KO\", \"BAC\", \"TSLA\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 6-day and 23-day EMAs. Trade AMD with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AMD\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 6)\n        self.long_ema = self.EMA(self.symbol, 23)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 6 above EMA 23\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 6 below EMA 23\")"
  },
  {
    "prompt": "Design a momentum strategy that trades QQQ, WMT, BAC, V, AMZN, META based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"QQQ\", \"WMT\", \"BAC\", \"V\", \"AMZN\", \"META\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for NVDA with 15-period and 1.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"NVDA\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 15, 1.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 15-day and 30-day EMAs. Trade PYPL with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PYPL\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 15)\n        self.long_ema = self.EMA(self.symbol, 30)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 15 above EMA 30\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 15 below EMA 30\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 5-day and 50-day SMAs. Trade ADBE with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"ADBE\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 5)\n        self.long_sma = self.SMA(self.symbol, 50)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 5 crossed above SMA 50\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 5 crossed below SMA 50\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Design a momentum strategy that trades JPM, QQQ, ADBE based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"JPM\", \"QQQ\", \"ADBE\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for SPY with 25-period and 2.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"SPY\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 25, 2.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a strategy with proper risk management including stop losses, position sizing based on ATR, and maximum drawdown controls.",
    "response": "from AlgorithmImports import *\n\nclass RiskManagedStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"SPY\", Resolution.Daily).Symbol\n        \n        # Indicators\n        self.sma_fast = self.SMA(self.symbol, 10)\n        self.sma_slow = self.SMA(self.symbol, 20)\n        self.atr = self.ATR(self.symbol, 14)\n        \n        # Risk management parameters\n        self.max_position_size = 0.1  # 10% max per position\n        self.risk_per_trade = 0.02    # 2% risk per trade\n        self.max_drawdown = 0.15      # 15% max drawdown\n        self.stop_multiplier = 2      # 2x ATR for stop loss\n        \n        # Track positions\n        self.entry_price = 0\n        self.stop_price = 0\n        self.peak_portfolio_value = self.Portfolio.TotalPortfolioValue\n        \n    def OnData(self, data):\n        if not (self.sma_fast.IsReady and self.sma_slow.IsReady and self.atr.IsReady):\n            return\n        \n        # Update peak portfolio value for drawdown calculation\n        current_value = self.Portfolio.TotalPortfolioValue\n        self.peak_portfolio_value = max(self.peak_portfolio_value, current_value)\n        \n        # Calculate current drawdown\n        drawdown = (self.peak_portfolio_value - current_value) / self.peak_portfolio_value\n        \n        # Emergency exit on max drawdown\n        if drawdown > self.max_drawdown:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"EMERGENCY EXIT: Max drawdown exceeded ({drawdown:.2%})\")\n            return\n        \n        price = data[self.symbol].Close\n        atr_value = self.atr.Current.Value\n        \n        # Entry logic\n        if not self.Portfolio[self.symbol].Invested:\n            if self.sma_fast.Current.Value > self.sma_slow.Current.Value:\n                # Calculate position size based on risk\n                risk_amount = current_value * self.risk_per_trade\n                stop_distance = atr_value * self.stop_multiplier\n                \n                if stop_distance > 0:\n                    shares = int(risk_amount / stop_distance)\n                    max_shares = int((current_value * self.max_position_size) / price)\n                    shares = min(shares, max_shares)\n                    \n                    if shares > 0:\n                        self.MarketOrder(self.symbol, shares)\n                        self.entry_price = price\n                        self.stop_price = price - stop_distance\n                        self.Log(f\"BUY: {shares} shares at {price:.2f}, Stop: {self.stop_price:.2f}\")\n        \n        # Exit logic\n        else:\n            # Stop loss\n            if price <= self.stop_price:\n                self.Liquidate(self.symbol)\n                self.Log(f\"STOP LOSS: Exit at {price:.2f}\")\n            \n            # Trailing stop (update stop price)\n            elif price > self.entry_price:\n                new_stop = price - (atr_value * self.stop_multiplier)\n                if new_stop > self.stop_price:\n                    self.stop_price = new_stop\n            \n            # Exit on trend change\n            elif self.sma_fast.Current.Value < self.sma_slow.Current.Value:\n                self.Liquidate(self.symbol)\n                self.Log(f\"TREND EXIT: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades AMZN, AAPL, PEP, INTC, META, TSLA based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"AMZN\", \"AAPL\", \"PEP\", \"INTC\", \"META\", \"TSLA\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades JNJ, PEP, JPM, ADBE, SPY, WMT based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"JNJ\", \"PEP\", \"JPM\", \"ADBE\", \"SPY\", \"WMT\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for ADBE with 25-period and 2.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"ADBE\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 25, 2.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for PG with 15-period and 2.0 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PG\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 15, 2.0)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 5-day and 35-day EMAs. Trade AAPL with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 5)\n        self.long_ema = self.EMA(self.symbol, 35)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 5 above EMA 35\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 5 below EMA 35\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for MSFT with 20-period and 2.0 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 20, 2.0)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 9-day and 50-day SMAs. Trade PEP with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 9)\n        self.long_sma = self.SMA(self.symbol, 50)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 9 crossed above SMA 50\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 9 crossed below SMA 50\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for NFLX with 20-period and 1.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"NFLX\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 20, 1.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 5-day and 39-day EMAs. Trade QQQ with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"QQQ\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 5)\n        self.long_ema = self.EMA(self.symbol, 39)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 5 above EMA 39\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 5 below EMA 39\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for KO with 15-period and 2.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 15, 2.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 14-day and 20-day EMAs. Trade GOOGL with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 14)\n        self.long_ema = self.EMA(self.symbol, 20)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 14 above EMA 20\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 14 below EMA 20\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 5-day and 50-day EMAs. Trade CRM with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"CRM\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 5)\n        self.long_ema = self.EMA(self.symbol, 50)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 5 above EMA 50\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 5 below EMA 50\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 5-day and 49-day EMAs. Trade TSLA with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"TSLA\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 5)\n        self.long_ema = self.EMA(self.symbol, 49)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 5 above EMA 49\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 5 below EMA 49\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for QQQ that buys when RSI < 22 and sells when RSI > 73. Use 5% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"QQQ\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.05\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 22:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 73:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades QQQ, AMZN, PG, KO, META based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"QQQ\", \"AMZN\", \"PG\", \"KO\", \"META\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for ADBE that buys when RSI < 23 and sells when RSI > 65. Use 15% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"ADBE\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.15\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 23:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 7-day and 23-day SMAs. Trade ADBE with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"ADBE\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 7)\n        self.long_sma = self.SMA(self.symbol, 23)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 7 crossed above SMA 23\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 7 crossed below SMA 23\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades PYPL, KO, TSLA based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"PYPL\", \"KO\", \"TSLA\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 14-day and 22-day EMAs. Trade WMT with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"WMT\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 14)\n        self.long_ema = self.EMA(self.symbol, 22)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 14 above EMA 22\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 14 below EMA 22\")"
  },
  {
    "prompt": "Design a momentum strategy that trades MA, WMT, CSCO, KO, PYPL based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"MA\", \"WMT\", \"CSCO\", \"KO\", \"PYPL\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades META, JPM, INTC based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"META\", \"JPM\", \"INTC\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 9-day and 33-day EMAs. Trade PYPL with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PYPL\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 9)\n        self.long_ema = self.EMA(self.symbol, 33)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 9 above EMA 33\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 9 below EMA 33\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for NFLX with 15-period and 1.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"NFLX\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 15, 1.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for V with 25-period and 2.0 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"V\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 25, 2.0)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades PG, JPM, PEP based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"PG\", \"JPM\", \"PEP\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for CSCO that buys when RSI < 28 and sells when RSI > 68. Use 15% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"CSCO\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.15\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 28:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 68:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for META that buys when RSI < 26 and sells when RSI > 76. Use 10% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.1\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 26:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 76:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for PG with 20-period and 1.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PG\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 20, 1.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 10-day and 26-day EMAs. Trade CRM with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"CRM\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 10)\n        self.long_ema = self.EMA(self.symbol, 26)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 10 above EMA 26\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 10 below EMA 26\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 7-day and 39-day SMAs. Trade SPY with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"SPY\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 7)\n        self.long_sma = self.SMA(self.symbol, 39)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 7 crossed above SMA 39\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 7 crossed below SMA 39\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Design a momentum strategy that trades MA, NFLX, TSLA, WMT based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"MA\", \"NFLX\", \"TSLA\", \"WMT\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for NFLX that buys when RSI < 21 and sells when RSI > 65. Use 5% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"NFLX\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.05\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 21:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 6-day and 50-day EMAs. Trade AMD with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AMD\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 6)\n        self.long_ema = self.EMA(self.symbol, 50)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 6 above EMA 50\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 6 below EMA 50\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for JNJ that buys when RSI < 20 and sells when RSI > 80. Use 20% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"JNJ\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.2\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 20:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 80:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades CSCO, WMT, GOOGL, BAC, PEP, CRM based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"CSCO\", \"WMT\", \"GOOGL\", \"BAC\", \"PEP\", \"CRM\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades META, CSCO, QQQ based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"META\", \"CSCO\", \"QQQ\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades INTC, JPM, AAPL based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"INTC\", \"JPM\", \"AAPL\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for MA that buys when RSI < 33 and sells when RSI > 71. Use 15% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MA\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.15\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 33:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 71:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades JPM, WMT, AAPL based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"JPM\", \"WMT\", \"AAPL\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades NFLX, CSCO, AAPL, CRM, KO, AMZN based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"NFLX\", \"CSCO\", \"AAPL\", \"CRM\", \"KO\", \"AMZN\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 11-day and 47-day EMAs. Trade NVDA with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"NVDA\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 11)\n        self.long_ema = self.EMA(self.symbol, 47)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 11 above EMA 47\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 11 below EMA 47\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades KO, PYPL, CSCO, AMZN, CRM based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"KO\", \"PYPL\", \"CSCO\", \"AMZN\", \"CRM\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades MSFT, INTC, META, PEP, AMZN based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"MSFT\", \"INTC\", \"META\", \"PEP\", \"AMZN\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for JPM that buys when RSI < 27 and sells when RSI > 69. Use 20% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.2\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 27:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 69:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 9-day and 33-day EMAs. Trade KO with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 9)\n        self.long_ema = self.EMA(self.symbol, 33)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 9 above EMA 33\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 9 below EMA 33\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for AMD that buys when RSI < 34 and sells when RSI > 65. Use 10% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AMD\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.1\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 34:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 12-day and 34-day EMAs. Trade JNJ with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"JNJ\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 12)\n        self.long_ema = self.EMA(self.symbol, 34)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 12 above EMA 34\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 12 below EMA 34\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades KO, JPM, NVDA, CSCO, PG, MSFT based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"KO\", \"JPM\", \"NVDA\", \"CSCO\", \"PG\", \"MSFT\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades NFLX, KO, BAC, TSLA, WMT, META based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"NFLX\", \"KO\", \"BAC\", \"TSLA\", \"WMT\", \"META\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for PEP that buys when RSI < 30 and sells when RSI > 68. Use 20% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.2\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 30:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 68:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades V, MA, JNJ, INTC based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"V\", \"MA\", \"JNJ\", \"INTC\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades META, BAC, ADBE, MA, TSLA based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"META\", \"BAC\", \"ADBE\", \"MA\", \"TSLA\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 9-day and 31-day EMAs. Trade ADBE with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"ADBE\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 9)\n        self.long_ema = self.EMA(self.symbol, 31)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 9 above EMA 31\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 9 below EMA 31\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for SPY with 25-period and 2.0 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"SPY\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 25, 2.0)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 7-day and 37-day SMAs. Trade NFLX with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"NFLX\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 7)\n        self.long_sma = self.SMA(self.symbol, 37)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 7 crossed above SMA 37\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 7 crossed below SMA 37\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Design a momentum strategy that trades V, GOOGL, AMD based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"V\", \"GOOGL\", \"AMD\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for CRM that buys when RSI < 29 and sells when RSI > 75. Use 15% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"CRM\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.15\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 29:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 75:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 6-day and 34-day SMAs. Trade QQQ with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"QQQ\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 6)\n        self.long_sma = self.SMA(self.symbol, 34)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 6 crossed above SMA 34\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 6 crossed below SMA 34\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a EMA crossover strategy using 6-day and 48-day EMAs. Trade MA with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MA\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 6)\n        self.long_ema = self.EMA(self.symbol, 48)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 6 above EMA 48\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 6 below EMA 48\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades ADBE, PG, AAPL, PYPL, AMD, TSLA based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"ADBE\", \"PG\", \"AAPL\", \"PYPL\", \"AMD\", \"TSLA\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades PG, GOOGL, JPM, ADBE, PEP based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"PG\", \"GOOGL\", \"JPM\", \"ADBE\", \"PEP\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades MSFT, NVDA, META, QQQ based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"MSFT\", \"NVDA\", \"META\", \"QQQ\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 11-day and 26-day SMAs. Trade GOOGL with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 11)\n        self.long_sma = self.SMA(self.symbol, 26)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 11 crossed above SMA 26\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 11 crossed below SMA 26\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for JNJ with 15-period and 2.0 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"JNJ\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 15, 2.0)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 11-day and 21-day EMAs. Trade MSFT with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 11)\n        self.long_ema = self.EMA(self.symbol, 21)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 11 above EMA 21\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 11 below EMA 21\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 10-day and 37-day SMAs. Trade NFLX with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"NFLX\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 10)\n        self.long_sma = self.SMA(self.symbol, 37)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 10 crossed above SMA 37\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 10 crossed below SMA 37\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Design a momentum strategy that trades KO, NVDA, PYPL, CRM based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"KO\", \"NVDA\", \"PYPL\", \"CRM\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades AMZN, CRM, AMD, JNJ, BAC based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"AMZN\", \"CRM\", \"AMD\", \"JNJ\", \"BAC\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades MSFT, QQQ, ADBE, META, BAC, AMZN based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"MSFT\", \"QQQ\", \"ADBE\", \"META\", \"BAC\", \"AMZN\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 10-day and 37-day EMAs. Trade JPM with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 10)\n        self.long_ema = self.EMA(self.symbol, 37)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 10 above EMA 37\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 10 below EMA 37\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for WMT that buys when RSI < 24 and sells when RSI > 65. Use 15% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"WMT\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.15\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 24:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 6-day and 27-day EMAs. Trade GOOGL with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 6)\n        self.long_ema = self.EMA(self.symbol, 27)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 6 above EMA 27\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 6 below EMA 27\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for INTC with 25-period and 2.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"INTC\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 25, 2.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 15-day and 32-day EMAs. Trade GOOGL with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 15)\n        self.long_ema = self.EMA(self.symbol, 32)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 15 above EMA 32\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 15 below EMA 32\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 11-day and 29-day EMAs. Trade PG with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PG\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 11)\n        self.long_ema = self.EMA(self.symbol, 29)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 11 above EMA 29\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 11 below EMA 29\")"
  },
  {
    "prompt": "Design a momentum strategy that trades PEP, PYPL, WMT based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"PEP\", \"PYPL\", \"WMT\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades PEP, JPM, AMZN based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"PEP\", \"JPM\", \"AMZN\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades multiple tech stocks (AAPL, MSFT, GOOGL) based on 50-day high breakouts.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"AAPL\", \"MSFT\", \"GOOGL\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for PG that buys when RSI < 35 and sells when RSI > 80. Use 15% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PG\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.15\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 80:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for AMD with 15-period and 1.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AMD\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 15, 1.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades META, MSFT, V, WMT based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"META\", \"MSFT\", \"V\", \"WMT\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for PEP that buys when RSI < 22 and sells when RSI > 71. Use 20% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.2\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 22:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 71:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for TSLA that buys when RSI < 25 and sells when RSI > 70. Use 15% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"TSLA\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.15\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 25:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 70:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades ADBE, KO, MA, MSFT based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"ADBE\", \"KO\", \"MA\", \"MSFT\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades WMT, ADBE, GOOGL, JNJ based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"WMT\", \"ADBE\", \"GOOGL\", \"JNJ\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades V, ADBE, PEP based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"V\", \"ADBE\", \"PEP\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades SPY, AAPL, META, NVDA, MA, AMD based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"SPY\", \"AAPL\", \"META\", \"NVDA\", \"MA\", \"AMD\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 14-day and 33-day SMAs. Trade BAC with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 14)\n        self.long_sma = self.SMA(self.symbol, 33)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 14 crossed above SMA 33\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 14 crossed below SMA 33\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Design a momentum strategy that trades NVDA, SPY, BAC, JNJ based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"NVDA\", \"SPY\", \"BAC\", \"JNJ\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades CRM, SPY, PG, NVDA, CSCO, AMZN based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"CRM\", \"SPY\", \"PG\", \"NVDA\", \"CSCO\", \"AMZN\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for AMZN that buys when RSI < 32 and sells when RSI > 65. Use 15% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AMZN\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.15\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 32:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades PG, CRM, SPY based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"PG\", \"CRM\", \"SPY\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 12-day and 41-day SMAs. Trade PEP with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 12)\n        self.long_sma = self.SMA(self.symbol, 41)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 12 crossed above SMA 41\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 12 crossed below SMA 41\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a SMA crossover strategy using 11-day and 29-day SMAs. Trade TSLA with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"TSLA\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 11)\n        self.long_sma = self.SMA(self.symbol, 29)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 11 crossed above SMA 29\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 11 crossed below SMA 29\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a EMA crossover strategy using 12-day and 27-day EMAs. Trade KO with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 12)\n        self.long_ema = self.EMA(self.symbol, 27)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 12 above EMA 27\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 12 below EMA 27\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 6-day and 38-day EMAs. Trade JNJ with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"JNJ\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 6)\n        self.long_ema = self.EMA(self.symbol, 38)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 6 above EMA 38\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 6 below EMA 38\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 13-day and 38-day SMAs. Trade ADBE with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"ADBE\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 13)\n        self.long_sma = self.SMA(self.symbol, 38)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 13 crossed above SMA 38\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 13 crossed below SMA 38\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Design a momentum strategy that trades BAC, INTC, V based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"BAC\", \"INTC\", \"V\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for WMT that buys when RSI < 22 and sells when RSI > 73. Use 15% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"WMT\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.15\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 22:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 73:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 10-day and 24-day SMAs. Trade NFLX with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"NFLX\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 10)\n        self.long_sma = self.SMA(self.symbol, 24)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 10 crossed above SMA 24\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 10 crossed below SMA 24\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Design a momentum strategy that trades CRM, SPY, WMT, AMD, JNJ based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"CRM\", \"SPY\", \"WMT\", \"AMD\", \"JNJ\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for GOOGL with 25-period and 1.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 25, 1.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for MA with 15-period and 2.0 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MA\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 15, 2.0)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades PG, PEP, NVDA based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"PG\", \"PEP\", \"NVDA\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for KO that buys when RSI < 35 and sells when RSI > 78. Use 15% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.15\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 78:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades GOOGL, PYPL, SPY, TSLA based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"GOOGL\", \"PYPL\", \"SPY\", \"TSLA\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades NFLX, AMZN, ADBE based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"NFLX\", \"AMZN\", \"ADBE\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades NFLX, MA, KO, ADBE, META, WMT based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"NFLX\", \"MA\", \"KO\", \"ADBE\", \"META\", \"WMT\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 9-day and 34-day SMAs. Trade GOOGL with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 9)\n        self.long_sma = self.SMA(self.symbol, 34)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 9 crossed above SMA 34\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 9 crossed below SMA 34\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for BAC that buys when RSI < 20 and sells when RSI > 72. Use 15% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.15\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 20:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 72:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for AAPL that buys when RSI < 24 and sells when RSI > 80. Use 20% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.2\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 24:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 80:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades TSLA, AAPL, KO, NVDA based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"TSLA\", \"AAPL\", \"KO\", \"NVDA\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 14-day and 37-day EMAs. Trade ADBE with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"ADBE\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 14)\n        self.long_ema = self.EMA(self.symbol, 37)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 14 above EMA 37\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 14 below EMA 37\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for PEP with 15-period and 2.0 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 15, 2.0)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades AMZN, NVDA, JPM based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"AMZN\", \"NVDA\", \"JPM\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades KO, AAPL, GOOGL, META based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"KO\", \"AAPL\", \"GOOGL\", \"META\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 15-day and 30-day EMAs. Trade MSFT with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 15)\n        self.long_ema = self.EMA(self.symbol, 30)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 15 above EMA 30\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 15 below EMA 30\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 13-day and 50-day EMAs. Trade PYPL with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PYPL\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 13)\n        self.long_ema = self.EMA(self.symbol, 50)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 13 above EMA 50\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 13 below EMA 50\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 10-day and 38-day SMAs. Trade GOOGL with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 10)\n        self.long_sma = self.SMA(self.symbol, 38)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 10 crossed above SMA 38\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 10 crossed below SMA 38\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Design a momentum strategy that trades GOOGL, AMD, QQQ, INTC, TSLA, SPY based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"GOOGL\", \"AMD\", \"QQQ\", \"INTC\", \"TSLA\", \"SPY\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 8-day and 34-day EMAs. Trade SPY with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"SPY\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 8)\n        self.long_ema = self.EMA(self.symbol, 34)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 8 above EMA 34\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 8 below EMA 34\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for CRM that buys when RSI < 29 and sells when RSI > 76. Use 5% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"CRM\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.05\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 29:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 76:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for BAC with 20-period and 1.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 20, 1.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 7-day and 46-day EMAs. Trade JPM with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 7)\n        self.long_ema = self.EMA(self.symbol, 46)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 7 above EMA 46\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 7 below EMA 46\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 10-day and 49-day EMAs. Trade INTC with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"INTC\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 10)\n        self.long_ema = self.EMA(self.symbol, 49)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 10 above EMA 49\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 10 below EMA 49\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 9-day and 20-day EMAs. Trade AMD with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AMD\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 9)\n        self.long_ema = self.EMA(self.symbol, 20)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 9 above EMA 20\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 9 below EMA 20\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for PG that buys when RSI < 25 and sells when RSI > 71. Use 15% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PG\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.15\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 25:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 71:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades JPM, QQQ, V, NVDA based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"JPM\", \"QQQ\", \"V\", \"NVDA\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for V with 20-period and 2.0 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"V\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 20, 2.0)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades QQQ, CSCO, ADBE, GOOGL, MSFT based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"QQQ\", \"CSCO\", \"ADBE\", \"GOOGL\", \"MSFT\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for CRM that buys when RSI < 21 and sells when RSI > 78. Use 10% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"CRM\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.1\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 21:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 78:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 6-day and 37-day EMAs. Trade V with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"V\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 6)\n        self.long_ema = self.EMA(self.symbol, 37)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 6 above EMA 37\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 6 below EMA 37\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for SPY with 25-period and 1.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"SPY\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 25, 1.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 15-day and 41-day SMAs. Trade JNJ with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"JNJ\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 15)\n        self.long_sma = self.SMA(self.symbol, 41)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 15 crossed above SMA 41\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 15 crossed below SMA 41\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for AMD that buys when RSI < 34 and sells when RSI > 69. Use 15% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AMD\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.15\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 34:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 69:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades SPY, NFLX, V based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"SPY\", \"NFLX\", \"V\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades CRM, V, GOOGL, QQQ, TSLA based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"CRM\", \"V\", \"GOOGL\", \"QQQ\", \"TSLA\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades BAC, PG, QQQ, WMT based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"BAC\", \"PG\", \"QQQ\", \"WMT\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades WMT, BAC, AAPL, MA based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"WMT\", \"BAC\", \"AAPL\", \"MA\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades JNJ, AMZN, WMT based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"JNJ\", \"AMZN\", \"WMT\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 13-day and 22-day SMAs. Trade META with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 13)\n        self.long_sma = self.SMA(self.symbol, 22)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 13 crossed above SMA 22\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 13 crossed below SMA 22\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for TSLA with 15-period and 2.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"TSLA\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 15, 2.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades PEP, MSFT, CRM, KO, JPM, AAPL based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"PEP\", \"MSFT\", \"CRM\", \"KO\", \"JPM\", \"AAPL\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades TSLA, CRM, NVDA, SPY, BAC based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"TSLA\", \"CRM\", \"NVDA\", \"SPY\", \"BAC\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades NVDA, JPM, MA, NFLX, TSLA based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"NVDA\", \"JPM\", \"MA\", \"NFLX\", \"TSLA\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for ADBE with 15-period and 2.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"ADBE\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 15, 2.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades TSLA, PEP, INTC, BAC, SPY, QQQ based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"TSLA\", \"PEP\", \"INTC\", \"BAC\", \"SPY\", \"QQQ\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for WMT that buys when RSI < 23 and sells when RSI > 74. Use 5% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"WMT\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.05\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 23:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 74:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for PYPL with 25-period and 2.0 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PYPL\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 25, 2.0)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for NVDA with 25-period and 2.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"NVDA\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 25, 2.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades PEP, QQQ, PYPL, TSLA based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"PEP\", \"QQQ\", \"PYPL\", \"TSLA\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 9-day and 20-day EMAs. Trade NVDA with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"NVDA\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 9)\n        self.long_ema = self.EMA(self.symbol, 20)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 9 above EMA 20\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 9 below EMA 20\")"
  },
  {
    "prompt": "Design a momentum strategy that trades PYPL, MA, NFLX, META, CSCO, MSFT based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"PYPL\", \"MA\", \"NFLX\", \"META\", \"CSCO\", \"MSFT\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 11-day and 30-day EMAs. Trade CRM with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"CRM\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 11)\n        self.long_ema = self.EMA(self.symbol, 30)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 11 above EMA 30\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 11 below EMA 30\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades JPM, PYPL, MSFT, SPY, NVDA, INTC based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"JPM\", \"PYPL\", \"MSFT\", \"SPY\", \"NVDA\", \"INTC\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades ADBE, AMZN, CSCO, WMT based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"ADBE\", \"AMZN\", \"CSCO\", \"WMT\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 13-day and 30-day SMAs. Trade PEP with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 13)\n        self.long_sma = self.SMA(self.symbol, 30)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 13 crossed above SMA 30\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 13 crossed below SMA 30\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a SMA crossover strategy using 7-day and 49-day SMAs. Trade MA with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MA\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 7)\n        self.long_sma = self.SMA(self.symbol, 49)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 7 crossed above SMA 49\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 7 crossed below SMA 49\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 10-day and 38-day SMAs. Trade GOOGL with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 10)\n        self.long_sma = self.SMA(self.symbol, 38)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 10 crossed above SMA 38\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 10 crossed below SMA 38\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades AMD, TSLA, MA, NVDA, NFLX based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"AMD\", \"TSLA\", \"MA\", \"NVDA\", \"NFLX\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades META, AMD, V, MA, WMT, AMZN based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"META\", \"AMD\", \"V\", \"MA\", \"WMT\", \"AMZN\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades GOOGL, TSLA, PYPL, NFLX based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"GOOGL\", \"TSLA\", \"PYPL\", \"NFLX\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 10-day and 36-day SMAs. Trade INTC with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"INTC\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 10)\n        self.long_sma = self.SMA(self.symbol, 36)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 10 crossed above SMA 36\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 10 crossed below SMA 36\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a SMA crossover strategy using 9-day and 47-day SMAs. Trade ADBE with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"ADBE\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 9)\n        self.long_sma = self.SMA(self.symbol, 47)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 9 crossed above SMA 47\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 9 crossed below SMA 47\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for MA with 25-period and 1.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MA\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 25, 1.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 7-day and 48-day SMAs. Trade KO with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 7)\n        self.long_sma = self.SMA(self.symbol, 48)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 7 crossed above SMA 48\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 7 crossed below SMA 48\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a SMA crossover strategy using 12-day and 40-day SMAs. Trade INTC with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"INTC\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 12)\n        self.long_sma = self.SMA(self.symbol, 40)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 12 crossed above SMA 40\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 12 crossed below SMA 40\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for INTC with 15-period and 2.0 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"INTC\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 15, 2.0)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades CSCO, V, INTC based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"CSCO\", \"V\", \"INTC\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for AMD that buys when RSI < 25 and sells when RSI > 68. Use 15% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AMD\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.15\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 25:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 68:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for INTC that buys when RSI < 29 and sells when RSI > 77. Use 20% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"INTC\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.2\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 29:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 77:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 13-day and 31-day EMAs. Trade PEP with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 13)\n        self.long_ema = self.EMA(self.symbol, 31)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 13 above EMA 31\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 13 below EMA 31\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for CRM that buys when RSI < 27 and sells when RSI > 76. Use 20% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"CRM\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.2\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 27:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 76:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for PYPL with 15-period and 2.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PYPL\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 15, 2.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for GOOGL with 20-period and 2.0 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 20, 2.0)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 9-day and 23-day SMAs. Trade WMT with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"WMT\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 9)\n        self.long_sma = self.SMA(self.symbol, 23)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 9 crossed above SMA 23\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 9 crossed below SMA 23\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 7-day and 27-day EMAs. Trade ADBE with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"ADBE\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 7)\n        self.long_ema = self.EMA(self.symbol, 27)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 7 above EMA 27\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 7 below EMA 27\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for AMZN that buys when RSI < 35 and sells when RSI > 77. Use 5% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AMZN\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.05\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 77:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 15-day and 38-day EMAs. Trade ADBE with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"ADBE\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 15)\n        self.long_ema = self.EMA(self.symbol, 38)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 15 above EMA 38\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 15 below EMA 38\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 11-day and 42-day SMAs. Trade V with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"V\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 11)\n        self.long_sma = self.SMA(self.symbol, 42)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 11 crossed above SMA 42\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 11 crossed below SMA 42\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 7-day and 35-day SMAs. Trade JNJ with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"JNJ\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 7)\n        self.long_sma = self.SMA(self.symbol, 35)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 7 crossed above SMA 35\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 7 crossed below SMA 35\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades META, V, ADBE, MA, AMZN, JPM based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"META\", \"V\", \"ADBE\", \"MA\", \"AMZN\", \"JPM\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades PEP, INTC, TSLA, ADBE, GOOGL based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"PEP\", \"INTC\", \"TSLA\", \"ADBE\", \"GOOGL\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades CRM, WMT, AMD based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"CRM\", \"WMT\", \"AMD\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 10-day and 45-day EMAs. Trade NVDA with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"NVDA\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 10)\n        self.long_ema = self.EMA(self.symbol, 45)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 10 above EMA 45\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 10 below EMA 45\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades NFLX, AMD, V, MA, KO based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"NFLX\", \"AMD\", \"V\", \"MA\", \"KO\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades V, MSFT, MA based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"V\", \"MSFT\", \"MA\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 6-day and 49-day EMAs. Trade PEP with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 6)\n        self.long_ema = self.EMA(self.symbol, 49)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 6 above EMA 49\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 6 below EMA 49\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 11-day and 26-day EMAs. Trade AMZN with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AMZN\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 11)\n        self.long_ema = self.EMA(self.symbol, 26)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 11 above EMA 26\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 11 below EMA 26\")"
  },
  {
    "prompt": "Design a momentum strategy that trades JPM, CRM, PYPL, MA based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"JPM\", \"CRM\", \"PYPL\", \"MA\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades NVDA, PEP, META, PYPL, TSLA based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"NVDA\", \"PEP\", \"META\", \"PYPL\", \"TSLA\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 10-day and 40-day SMAs. Trade META with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 10)\n        self.long_sma = self.SMA(self.symbol, 40)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 10 crossed above SMA 40\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 10 crossed below SMA 40\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Design a momentum strategy that trades WMT, QQQ, AAPL, KO based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"WMT\", \"QQQ\", \"AAPL\", \"KO\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 12-day and 29-day SMAs. Trade SPY with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"SPY\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 12)\n        self.long_sma = self.SMA(self.symbol, 29)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 12 crossed above SMA 29\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 12 crossed below SMA 29\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 11-day and 30-day SMAs. Trade SPY with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"SPY\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 11)\n        self.long_sma = self.SMA(self.symbol, 30)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 11 crossed above SMA 30\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 11 crossed below SMA 30\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 8-day and 26-day EMAs. Trade AMZN with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AMZN\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 8)\n        self.long_ema = self.EMA(self.symbol, 26)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 8 above EMA 26\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 8 below EMA 26\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for BAC with 20-period and 2.0 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 20, 2.0)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for CRM that buys when RSI < 34 and sells when RSI > 77. Use 20% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"CRM\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.2\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 34:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 77:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 6-day and 20-day SMAs. Trade INTC with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"INTC\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 6)\n        self.long_sma = self.SMA(self.symbol, 20)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 6 crossed above SMA 20\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 6 crossed below SMA 20\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Design a momentum strategy that trades TSLA, AMZN, WMT, JNJ, JPM based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"TSLA\", \"AMZN\", \"WMT\", \"JNJ\", \"JPM\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades AAPL, BAC, MSFT, TSLA, META based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"AAPL\", \"BAC\", \"MSFT\", \"TSLA\", \"META\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 10-day and 50-day EMAs. Trade KO with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 10)\n        self.long_ema = self.EMA(self.symbol, 50)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 10 above EMA 50\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 10 below EMA 50\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades JNJ, NVDA, PG based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"JNJ\", \"NVDA\", \"PG\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for AAPL with 25-period and 2.0 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 25, 2.0)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for SPY that buys when RSI < 25 and sells when RSI > 77. Use 20% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"SPY\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.2\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 25:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 77:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades ADBE, PEP, AMD based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"ADBE\", \"PEP\", \"AMD\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for BAC with 15-period and 2.0 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 15, 2.0)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for JNJ with 20-period and 1.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"JNJ\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 20, 1.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for NVDA that buys when RSI < 31 and sells when RSI > 76. Use 5% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"NVDA\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.05\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 31:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 76:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades GOOGL, META, ADBE, PYPL, CRM, AAPL based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"GOOGL\", \"META\", \"ADBE\", \"PYPL\", \"CRM\", \"AAPL\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades MSFT, AAPL, META, PYPL, V based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"MSFT\", \"AAPL\", \"META\", \"PYPL\", \"V\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 9-day and 44-day SMAs. Trade MSFT with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 9)\n        self.long_sma = self.SMA(self.symbol, 44)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 9 crossed above SMA 44\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 9 crossed below SMA 44\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 12-day and 50-day EMAs. Trade BAC with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 12)\n        self.long_ema = self.EMA(self.symbol, 50)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 12 above EMA 50\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 12 below EMA 50\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for PEP with 25-period and 2.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 25, 2.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 13-day and 33-day SMAs. Trade ADBE with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"ADBE\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 13)\n        self.long_sma = self.SMA(self.symbol, 33)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 13 crossed above SMA 33\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 13 crossed below SMA 33\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 9-day and 37-day SMAs. Trade BAC with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 9)\n        self.long_sma = self.SMA(self.symbol, 37)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 9 crossed above SMA 37\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 9 crossed below SMA 37\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a EMA crossover strategy using 9-day and 37-day EMAs. Trade AMZN with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AMZN\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 9)\n        self.long_ema = self.EMA(self.symbol, 37)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 9 above EMA 37\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 9 below EMA 37\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for JPM with 25-period and 1.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 25, 1.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades MA, GOOGL, QQQ, KO, CSCO based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"MA\", \"GOOGL\", \"QQQ\", \"KO\", \"CSCO\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for INTC with 20-period and 2.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"INTC\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 20, 2.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for V with 25-period and 2.0 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"V\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 25, 2.0)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for PG with 20-period and 2.0 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PG\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 20, 2.0)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for MSFT that buys when RSI < 24 and sells when RSI > 71. Use 20% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.2\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 24:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 71:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 7-day and 50-day EMAs. Trade PG with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PG\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 7)\n        self.long_ema = self.EMA(self.symbol, 50)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 7 above EMA 50\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 7 below EMA 50\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 9-day and 48-day EMAs. Trade MSFT with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 9)\n        self.long_ema = self.EMA(self.symbol, 48)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 9 above EMA 48\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 9 below EMA 48\")"
  },
  {
    "prompt": "Implement an RSI mean reversion strategy that buys when RSI < 30 and sells when RSI > 70. Trade QQQ with 10% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"QQQ\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.1\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 30:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 70:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades JNJ, AMZN, AMD, CSCO based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"JNJ\", \"AMZN\", \"AMD\", \"CSCO\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 10-day and 29-day EMAs. Trade SPY with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"SPY\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 10)\n        self.long_ema = self.EMA(self.symbol, 29)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 10 above EMA 29\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 10 below EMA 29\")"
  },
  {
    "prompt": "Design a momentum strategy that trades PG, SPY, INTC, QQQ, NFLX based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"PG\", \"SPY\", \"INTC\", \"QQQ\", \"NFLX\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for META that buys when RSI < 21 and sells when RSI > 78. Use 15% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.15\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 21:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 78:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for MSFT that buys when RSI < 32 and sells when RSI > 72. Use 10% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.1\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 32:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 72:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for NVDA that buys when RSI < 23 and sells when RSI > 77. Use 20% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"NVDA\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.2\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 23:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 77:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades MA, CRM, AAPL based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"MA\", \"CRM\", \"AAPL\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for V with 25-period and 1.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"V\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 25, 1.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for NVDA with 20-period and 2.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"NVDA\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 20, 2.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for JNJ with 25-period and 2.0 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"JNJ\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 25, 2.0)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 6-day and 50-day SMAs. Trade PG with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PG\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 6)\n        self.long_sma = self.SMA(self.symbol, 50)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 6 crossed above SMA 50\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 6 crossed below SMA 50\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a EMA crossover strategy using 8-day and 25-day EMAs. Trade SPY with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"SPY\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 8)\n        self.long_ema = self.EMA(self.symbol, 25)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 8 above EMA 25\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 8 below EMA 25\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for KO that buys when RSI < 24 and sells when RSI > 73. Use 20% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.2\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 24:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 73:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades GOOGL, MA, V, AAPL, WMT, ADBE based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"GOOGL\", \"MA\", \"V\", \"AAPL\", \"WMT\", \"ADBE\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades INTC, NVDA, PG, QQQ, JNJ, GOOGL based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"INTC\", \"NVDA\", \"PG\", \"QQQ\", \"JNJ\", \"GOOGL\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 15-day and 32-day EMAs. Trade SPY with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"SPY\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 15)\n        self.long_ema = self.EMA(self.symbol, 32)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 15 above EMA 32\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 15 below EMA 32\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 10-day and 46-day EMAs. Trade MSFT with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 10)\n        self.long_ema = self.EMA(self.symbol, 46)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 10 above EMA 46\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 10 below EMA 46\")"
  },
  {
    "prompt": "Design a momentum strategy that trades TSLA, KO, PG based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"TSLA\", \"KO\", \"PG\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades GOOGL, KO, JNJ, PG, CSCO, MA based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"GOOGL\", \"KO\", \"JNJ\", \"PG\", \"CSCO\", \"MA\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades META, WMT, MA, GOOGL, JNJ based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"META\", \"WMT\", \"MA\", \"GOOGL\", \"JNJ\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 11-day and 29-day EMAs. Trade PYPL with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PYPL\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 11)\n        self.long_ema = self.EMA(self.symbol, 29)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 11 above EMA 29\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 11 below EMA 29\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades ADBE, MA, INTC based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"ADBE\", \"MA\", \"INTC\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades QQQ, AAPL, MA, SPY, NFLX, CRM based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"QQQ\", \"AAPL\", \"MA\", \"SPY\", \"NFLX\", \"CRM\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 13-day and 33-day SMAs. Trade INTC with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"INTC\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 13)\n        self.long_sma = self.SMA(self.symbol, 33)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 13 crossed above SMA 33\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 13 crossed below SMA 33\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a EMA crossover strategy using 14-day and 26-day EMAs. Trade AAPL with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 14)\n        self.long_ema = self.EMA(self.symbol, 26)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 14 above EMA 26\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 14 below EMA 26\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for AMD with 15-period and 2.0 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AMD\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 15, 2.0)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades META, TSLA, QQQ based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"META\", \"TSLA\", \"QQQ\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for NFLX that buys when RSI < 29 and sells when RSI > 66. Use 10% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"NFLX\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.1\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 29:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 66:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 8-day and 48-day EMAs. Trade META with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 8)\n        self.long_ema = self.EMA(self.symbol, 48)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 8 above EMA 48\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 8 below EMA 48\")"
  },
  {
    "prompt": "Design a momentum strategy that trades MSFT, NVDA, WMT, PG, V, AAPL based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"MSFT\", \"NVDA\", \"WMT\", \"PG\", \"V\", \"AAPL\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for MA that buys when RSI < 32 and sells when RSI > 65. Use 5% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MA\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.05\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 32:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 11-day and 25-day SMAs. Trade CRM with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"CRM\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 11)\n        self.long_sma = self.SMA(self.symbol, 25)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 11 crossed above SMA 25\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 11 crossed below SMA 25\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Design a momentum strategy that trades BAC, JNJ, CSCO, AMZN, AMD, PYPL based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"BAC\", \"JNJ\", \"CSCO\", \"AMZN\", \"AMD\", \"PYPL\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 14-day and 39-day SMAs. Trade JNJ with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"JNJ\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 14)\n        self.long_sma = self.SMA(self.symbol, 39)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 14 crossed above SMA 39\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 14 crossed below SMA 39\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a SMA crossover strategy using 8-day and 48-day SMAs. Trade BAC with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 8)\n        self.long_sma = self.SMA(self.symbol, 48)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 8 crossed above SMA 48\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 8 crossed below SMA 48\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a EMA crossover strategy using 7-day and 28-day EMAs. Trade AMZN with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AMZN\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 7)\n        self.long_ema = self.EMA(self.symbol, 28)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 7 above EMA 28\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 7 below EMA 28\")"
  },
  {
    "prompt": "Design a momentum strategy that trades META, TSLA, CSCO, QQQ based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"META\", \"TSLA\", \"CSCO\", \"QQQ\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for GOOGL with 25-period and 1.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 25, 1.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades AMD, JNJ, AMZN, AAPL, JPM based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"AMD\", \"JNJ\", \"AMZN\", \"AAPL\", \"JPM\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for CSCO with 25-period and 2.0 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"CSCO\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 25, 2.0)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades SPY, KO, MSFT based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"SPY\", \"KO\", \"MSFT\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for META with 20-period and 2.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 20, 2.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 14-day and 37-day SMAs. Trade MSFT with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 14)\n        self.long_sma = self.SMA(self.symbol, 37)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 14 crossed above SMA 37\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 14 crossed below SMA 37\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Design a momentum strategy that trades PEP, BAC, QQQ based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"PEP\", \"BAC\", \"QQQ\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 9-day and 28-day SMAs. Trade ADBE with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"ADBE\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 9)\n        self.long_sma = self.SMA(self.symbol, 28)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 9 crossed above SMA 28\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 9 crossed below SMA 28\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for PEP that buys when RSI < 30 and sells when RSI > 79. Use 20% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.2\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 30:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 79:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 11-day and 35-day EMAs. Trade JNJ with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"JNJ\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 11)\n        self.long_ema = self.EMA(self.symbol, 35)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 11 above EMA 35\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 11 below EMA 35\")"
  },
  {
    "prompt": "Design a momentum strategy that trades TSLA, PG, JPM, CRM, WMT, META based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"TSLA\", \"PG\", \"JPM\", \"CRM\", \"WMT\", \"META\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades MSFT, QQQ, AMZN based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"MSFT\", \"QQQ\", \"AMZN\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for KO that buys when RSI < 23 and sells when RSI > 69. Use 15% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.15\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 23:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 69:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 9-day and 25-day EMAs. Trade META with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 9)\n        self.long_ema = self.EMA(self.symbol, 25)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 9 above EMA 25\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 9 below EMA 25\")"
  },
  {
    "prompt": "Design a momentum strategy that trades QQQ, KO, JPM, AAPL, AMZN, PG based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"QQQ\", \"KO\", \"JPM\", \"AAPL\", \"AMZN\", \"PG\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for NFLX with 25-period and 1.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"NFLX\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 25, 1.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 15-day and 20-day SMAs. Trade AMD with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AMD\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 15)\n        self.long_sma = self.SMA(self.symbol, 20)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 15 crossed above SMA 20\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 15 crossed below SMA 20\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a SMA crossover strategy using 13-day and 20-day SMAs. Trade ADBE with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"ADBE\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 13)\n        self.long_sma = self.SMA(self.symbol, 20)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 13 crossed above SMA 20\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 13 crossed below SMA 20\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for PEP that buys when RSI < 25 and sells when RSI > 80. Use 10% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.1\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 25:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 80:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades MA, INTC, CSCO, CRM, QQQ based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"MA\", \"INTC\", \"CSCO\", \"CRM\", \"QQQ\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 9-day and 42-day EMAs. Trade QQQ with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"QQQ\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 9)\n        self.long_ema = self.EMA(self.symbol, 42)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 9 above EMA 42\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 9 below EMA 42\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 8-day and 25-day SMAs. Trade SPY with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"SPY\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 8)\n        self.long_sma = self.SMA(self.symbol, 25)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 8 crossed above SMA 25\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 8 crossed below SMA 25\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a EMA crossover strategy using 13-day and 45-day EMAs. Trade AMZN with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AMZN\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 13)\n        self.long_ema = self.EMA(self.symbol, 45)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 13 above EMA 45\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 13 below EMA 45\")"
  },
  {
    "prompt": "Design a momentum strategy that trades QQQ, PYPL, TSLA, JNJ, AAPL based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"QQQ\", \"PYPL\", \"TSLA\", \"JNJ\", \"AAPL\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 6-day and 22-day EMAs. Trade META with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 6)\n        self.long_ema = self.EMA(self.symbol, 22)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 6 above EMA 22\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 6 below EMA 22\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 11-day and 24-day EMAs. Trade JPM with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 11)\n        self.long_ema = self.EMA(self.symbol, 24)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 11 above EMA 24\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 11 below EMA 24\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 12-day and 44-day EMAs. Trade BAC with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 12)\n        self.long_ema = self.EMA(self.symbol, 44)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 12 above EMA 44\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 12 below EMA 44\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for TSLA that buys when RSI < 29 and sells when RSI > 65. Use 15% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"TSLA\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.15\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 29:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades JNJ, V, AAPL based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"JNJ\", \"V\", \"AAPL\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades MA, TSLA, QQQ based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"MA\", \"TSLA\", \"QQQ\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 8-day and 20-day EMAs. Trade AMD with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AMD\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 8)\n        self.long_ema = self.EMA(self.symbol, 20)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 8 above EMA 20\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 8 below EMA 20\")"
  },
  {
    "prompt": "Design a momentum strategy that trades AMD, GOOGL, NFLX, WMT, MA, QQQ based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"AMD\", \"GOOGL\", \"NFLX\", \"WMT\", \"MA\", \"QQQ\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades ADBE, AMZN, SPY based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"ADBE\", \"AMZN\", \"SPY\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for TSLA with 15-period and 1.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"TSLA\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 15, 1.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 7-day and 44-day SMAs. Trade JPM with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 7)\n        self.long_sma = self.SMA(self.symbol, 44)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 7 crossed above SMA 44\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 7 crossed below SMA 44\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for CRM that buys when RSI < 28 and sells when RSI > 73. Use 5% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"CRM\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.05\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 28:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 73:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for KO that buys when RSI < 29 and sells when RSI > 67. Use 5% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.05\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 29:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 67:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades WMT, CRM, NVDA, JPM, BAC based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"WMT\", \"CRM\", \"NVDA\", \"JPM\", \"BAC\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 14-day and 31-day EMAs. Trade BAC with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 14)\n        self.long_ema = self.EMA(self.symbol, 31)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 14 above EMA 31\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 14 below EMA 31\")"
  },
  {
    "prompt": "Design a momentum strategy that trades MSFT, PEP, PG based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"MSFT\", \"PEP\", \"PG\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 14-day and 35-day SMAs. Trade PYPL with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PYPL\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 14)\n        self.long_sma = self.SMA(self.symbol, 35)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 14 crossed above SMA 35\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 14 crossed below SMA 35\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 6-day and 33-day SMAs. Trade AMD with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AMD\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 6)\n        self.long_sma = self.SMA(self.symbol, 33)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 6 crossed above SMA 33\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 6 crossed below SMA 33\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a SMA crossover strategy using 14-day and 44-day SMAs. Trade WMT with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"WMT\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 14)\n        self.long_sma = self.SMA(self.symbol, 44)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 14 crossed above SMA 44\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 14 crossed below SMA 44\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for AAPL with 20-period and 2.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 20, 2.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for PEP that buys when RSI < 31 and sells when RSI > 70. Use 10% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.1\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 31:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 70:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for V that buys when RSI < 32 and sells when RSI > 75. Use 15% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"V\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.15\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 32:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 75:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 8-day and 48-day EMAs. Trade MA with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MA\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 8)\n        self.long_ema = self.EMA(self.symbol, 48)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 8 above EMA 48\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 8 below EMA 48\")"
  },
  {
    "prompt": "Design a momentum strategy that trades QQQ, SPY, KO, AMZN, BAC based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"QQQ\", \"SPY\", \"KO\", \"AMZN\", \"BAC\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 6-day and 42-day EMAs. Trade JNJ with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"JNJ\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 6)\n        self.long_ema = self.EMA(self.symbol, 42)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 6 above EMA 42\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 6 below EMA 42\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for CSCO that buys when RSI < 26 and sells when RSI > 76. Use 10% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"CSCO\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.1\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 26:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 76:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for QQQ with 20-period and 2.0 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"QQQ\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 20, 2.0)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades JPM, BAC, GOOGL based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"JPM\", \"BAC\", \"GOOGL\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades JNJ, META, QQQ based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"JNJ\", \"META\", \"QQQ\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for MA with 15-period and 1.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MA\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 15, 1.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 9-day and 48-day SMAs. Trade INTC with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"INTC\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 9)\n        self.long_sma = self.SMA(self.symbol, 48)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 9 crossed above SMA 48\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 9 crossed below SMA 48\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Design a momentum strategy that trades MSFT, NVDA, WMT, PYPL, MA based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"MSFT\", \"NVDA\", \"WMT\", \"PYPL\", \"MA\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 10-day and 46-day EMAs. Trade AMZN with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AMZN\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 10)\n        self.long_ema = self.EMA(self.symbol, 46)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 10 above EMA 46\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 10 below EMA 46\")"
  },
  {
    "prompt": "Design a momentum strategy that trades CSCO, TSLA, JNJ, BAC based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"CSCO\", \"TSLA\", \"JNJ\", \"BAC\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for PEP that buys when RSI < 30 and sells when RSI > 65. Use 15% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.15\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 30:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 15-day and 34-day SMAs. Trade JPM with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 15)\n        self.long_sma = self.SMA(self.symbol, 34)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 15 crossed above SMA 34\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 15 crossed below SMA 34\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 7-day and 22-day EMAs. Trade SPY with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"SPY\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 7)\n        self.long_ema = self.EMA(self.symbol, 22)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 7 above EMA 22\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 7 below EMA 22\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 9-day and 48-day SMAs. Trade MSFT with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 9)\n        self.long_sma = self.SMA(self.symbol, 48)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 9 crossed above SMA 48\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 9 crossed below SMA 48\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for AAPL that buys when RSI < 35 and sells when RSI > 70. Use 20% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.2\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 70:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades MA, PEP, META, NFLX, AMZN, PG based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"MA\", \"PEP\", \"META\", \"NFLX\", \"AMZN\", \"PG\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades NVDA, BAC, PG based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"NVDA\", \"BAC\", \"PG\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for MA with 20-period and 2.0 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MA\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 20, 2.0)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades MSFT, AAPL, PG based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"MSFT\", \"AAPL\", \"PG\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 7-day and 47-day EMAs. Trade SPY with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"SPY\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 7)\n        self.long_ema = self.EMA(self.symbol, 47)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 7 above EMA 47\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 7 below EMA 47\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 9-day and 31-day SMAs. Trade CRM with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"CRM\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 9)\n        self.long_sma = self.SMA(self.symbol, 31)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 9 crossed above SMA 31\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 9 crossed below SMA 31\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades QQQ, PEP, WMT, PG, AAPL based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"QQQ\", \"PEP\", \"WMT\", \"PG\", \"AAPL\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades NVDA, WMT, JPM, MSFT based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"NVDA\", \"WMT\", \"JPM\", \"MSFT\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 10-day and 23-day EMAs. Trade NVDA with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"NVDA\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 10)\n        self.long_ema = self.EMA(self.symbol, 23)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 10 above EMA 23\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 10 below EMA 23\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for META with 15-period and 2.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 15, 2.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 10-day and 38-day EMAs. Trade NFLX with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"NFLX\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 10)\n        self.long_ema = self.EMA(self.symbol, 38)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 10 above EMA 38\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 10 below EMA 38\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 6-day and 45-day SMAs. Trade META with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 6)\n        self.long_sma = self.SMA(self.symbol, 45)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 6 crossed above SMA 45\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 6 crossed below SMA 45\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Design a momentum strategy that trades AMD, NFLX, GOOGL, QQQ, MA based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"AMD\", \"NFLX\", \"GOOGL\", \"QQQ\", \"MA\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 12-day and 35-day EMAs. Trade NVDA with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"NVDA\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 12)\n        self.long_ema = self.EMA(self.symbol, 35)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 12 above EMA 35\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 12 below EMA 35\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 10-day and 39-day EMAs. Trade JNJ with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"JNJ\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 10)\n        self.long_ema = self.EMA(self.symbol, 39)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 10 above EMA 39\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 10 below EMA 39\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for MA with 20-period and 1.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MA\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 20, 1.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for QQQ that buys when RSI < 35 and sells when RSI > 78. Use 15% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"QQQ\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.15\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 78:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades SPY, PG, META, CRM based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"SPY\", \"PG\", \"META\", \"CRM\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades MSFT, PG, MA, SPY, INTC based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"MSFT\", \"PG\", \"MA\", \"SPY\", \"INTC\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades GOOGL, NVDA, BAC based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"GOOGL\", \"NVDA\", \"BAC\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 5-day and 33-day SMAs. Trade PG with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PG\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 5)\n        self.long_sma = self.SMA(self.symbol, 33)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 5 crossed above SMA 33\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 5 crossed below SMA 33\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades CSCO, AAPL, KO based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"CSCO\", \"AAPL\", \"KO\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 10-day and 35-day EMAs. Trade AMD with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AMD\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 10)\n        self.long_ema = self.EMA(self.symbol, 35)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 10 above EMA 35\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 10 below EMA 35\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for PYPL that buys when RSI < 29 and sells when RSI > 68. Use 5% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PYPL\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.05\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 29:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 68:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for INTC that buys when RSI < 32 and sells when RSI > 76. Use 15% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"INTC\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.15\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 32:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 76:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for PYPL that buys when RSI < 25 and sells when RSI > 72. Use 5% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PYPL\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.05\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 25:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 72:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for TSLA with 15-period and 2.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"TSLA\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 15, 2.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades TSLA, GOOGL, KO, INTC, PG based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"TSLA\", \"GOOGL\", \"KO\", \"INTC\", \"PG\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 8-day and 39-day EMAs. Trade WMT with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"WMT\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 8)\n        self.long_ema = self.EMA(self.symbol, 39)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 8 above EMA 39\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 8 below EMA 39\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 12-day and 26-day SMAs. Trade INTC with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"INTC\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 12)\n        self.long_sma = self.SMA(self.symbol, 26)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 12 crossed above SMA 26\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 12 crossed below SMA 26\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Design a momentum strategy that trades PEP, JPM, V, META, WMT, NVDA based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"PEP\", \"JPM\", \"V\", \"META\", \"WMT\", \"NVDA\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades JPM, V, AAPL, SPY, PYPL, MA based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"JPM\", \"V\", \"AAPL\", \"SPY\", \"PYPL\", \"MA\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades AMD, GOOGL, NFLX, TSLA, BAC based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"AMD\", \"GOOGL\", \"NFLX\", \"TSLA\", \"BAC\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for V that buys when RSI < 30 and sells when RSI > 66. Use 10% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"V\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.1\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 30:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 66:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 12-day and 37-day EMAs. Trade AAPL with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 12)\n        self.long_ema = self.EMA(self.symbol, 37)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 12 above EMA 37\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 12 below EMA 37\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 7-day and 33-day SMAs. Trade AMD with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AMD\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 7)\n        self.long_sma = self.SMA(self.symbol, 33)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 7 crossed above SMA 33\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 7 crossed below SMA 33\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a EMA crossover strategy using 12-day and 47-day EMAs. Trade BAC with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 12)\n        self.long_ema = self.EMA(self.symbol, 47)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 12 above EMA 47\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 12 below EMA 47\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 8-day and 44-day EMAs. Trade MSFT with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 8)\n        self.long_ema = self.EMA(self.symbol, 44)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 8 above EMA 44\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 8 below EMA 44\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades PEP, JPM, JNJ, WMT based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"PEP\", \"JPM\", \"JNJ\", \"WMT\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 13-day and 47-day EMAs. Trade CRM with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"CRM\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 13)\n        self.long_ema = self.EMA(self.symbol, 47)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 13 above EMA 47\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 13 below EMA 47\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for MA with 20-period and 1.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MA\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 20, 1.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 11-day and 26-day SMAs. Trade KO with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 11)\n        self.long_sma = self.SMA(self.symbol, 26)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 11 crossed above SMA 26\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 11 crossed below SMA 26\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 14-day and 25-day EMAs. Trade QQQ with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"QQQ\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 14)\n        self.long_ema = self.EMA(self.symbol, 25)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 14 above EMA 25\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 14 below EMA 25\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for AMD with 25-period and 1.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AMD\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 25, 1.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades MSFT, KO, AAPL, PEP, INTC, AMZN based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"MSFT\", \"KO\", \"AAPL\", \"PEP\", \"INTC\", \"AMZN\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for JNJ that buys when RSI < 22 and sells when RSI > 78. Use 15% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"JNJ\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.15\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 22:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 78:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades QQQ, V, WMT based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"QQQ\", \"V\", \"WMT\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for NFLX with 25-period and 2.0 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"NFLX\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 25, 2.0)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 10-day and 37-day EMAs. Trade KO with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 10)\n        self.long_ema = self.EMA(self.symbol, 37)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 10 above EMA 37\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 10 below EMA 37\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for TSLA that buys when RSI < 24 and sells when RSI > 79. Use 15% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"TSLA\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.15\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 24:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 79:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 6-day and 40-day EMAs. Trade PEP with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 6)\n        self.long_ema = self.EMA(self.symbol, 40)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 6 above EMA 40\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 6 below EMA 40\")"
  },
  {
    "prompt": "Design a momentum strategy that trades ADBE, NVDA, GOOGL, META, WMT, CSCO based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"ADBE\", \"NVDA\", \"GOOGL\", \"META\", \"WMT\", \"CSCO\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades PG, MSFT, QQQ, NVDA based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"PG\", \"MSFT\", \"QQQ\", \"NVDA\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 10-day and 33-day SMAs. Trade AMD with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AMD\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 10)\n        self.long_sma = self.SMA(self.symbol, 33)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 10 crossed above SMA 33\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 10 crossed below SMA 33\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Design a momentum strategy that trades NVDA, INTC, JNJ, KO, TSLA, MSFT based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"NVDA\", \"INTC\", \"JNJ\", \"KO\", \"TSLA\", \"MSFT\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for INTC with 15-period and 2.0 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"INTC\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 15, 2.0)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades GOOGL, AMZN, WMT based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"GOOGL\", \"AMZN\", \"WMT\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 10-day and 34-day EMAs. Trade JPM with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 10)\n        self.long_ema = self.EMA(self.symbol, 34)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 10 above EMA 34\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 10 below EMA 34\")"
  },
  {
    "prompt": "Design a momentum strategy that trades AMZN, CSCO, WMT based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"AMZN\", \"CSCO\", \"WMT\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for MA with 25-period and 1.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MA\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 25, 1.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades PYPL, WMT, META, CRM based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"PYPL\", \"WMT\", \"META\", \"CRM\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for NFLX that buys when RSI < 23 and sells when RSI > 65. Use 15% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"NFLX\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.15\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 23:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 11-day and 50-day SMAs. Trade JNJ with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"JNJ\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 11)\n        self.long_sma = self.SMA(self.symbol, 50)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 11 crossed above SMA 50\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 11 crossed below SMA 50\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Design a momentum strategy that trades NFLX, INTC, JPM, AMD, PEP, WMT based on 20-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"NFLX\", \"INTC\", \"JPM\", \"AMD\", \"PEP\", \"WMT\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 20)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_20 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 20-day high\n            if price > high_20 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_20 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 11-day and 42-day SMAs. Trade BAC with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 11)\n        self.long_sma = self.SMA(self.symbol, 42)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 11 crossed above SMA 42\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 11 crossed below SMA 42\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Design a momentum strategy that trades V, MA, PG, WMT, AAPL, ADBE based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"V\", \"MA\", \"PG\", \"WMT\", \"AAPL\", \"ADBE\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for CRM that buys when RSI < 31 and sells when RSI > 72. Use 15% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"CRM\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.15\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 31:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 72:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for GOOGL with 15-period and 1.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 15, 1.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 11-day and 49-day SMAs. Trade PEP with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 11)\n        self.long_sma = self.SMA(self.symbol, 49)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 11 crossed above SMA 49\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 11 crossed below SMA 49\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for META with 20-period and 2.0 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 20, 2.0)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for AMD with 20-period and 2.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AMD\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 20, 2.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for INTC that buys when RSI < 26 and sells when RSI > 76. Use 15% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"INTC\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.15\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 26:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 76:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades NVDA, ADBE, AMD, CRM, INTC based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"NVDA\", \"ADBE\", \"AMD\", \"CRM\", \"INTC\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades CSCO, V, MSFT, AMZN, ADBE, JPM based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"CSCO\", \"V\", \"MSFT\", \"AMZN\", \"ADBE\", \"JPM\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades PYPL, JNJ, GOOGL based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"PYPL\", \"JNJ\", \"GOOGL\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for JNJ with 15-period and 2.0 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"JNJ\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 15, 2.0)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades PYPL, META, NVDA, CRM, V based on 100-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"PYPL\", \"META\", \"NVDA\", \"CRM\", \"V\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 100)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_100 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 100-day high\n            if price > high_100 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_100 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 15-day and 49-day EMAs. Trade AAPL with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 15)\n        self.long_ema = self.EMA(self.symbol, 49)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 15 above EMA 49\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 15 below EMA 49\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 8-day and 50-day EMAs. Trade ADBE with $100,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"ADBE\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 8)\n        self.long_ema = self.EMA(self.symbol, 50)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 8 above EMA 50\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 8 below EMA 50\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 10-day and 20-day SMAs. Trade MSFT with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 10)\n        self.long_sma = self.SMA(self.symbol, 20)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 10 crossed above SMA 20\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 10 crossed below SMA 20\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades AAPL, META, MSFT, BAC, V, PYPL based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"AAPL\", \"META\", \"MSFT\", \"BAC\", \"V\", \"PYPL\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 5-day and 33-day SMAs. Trade AMZN with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"AMZN\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 5)\n        self.long_sma = self.SMA(self.symbol, 33)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 5 crossed above SMA 33\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 5 crossed below SMA 33\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 6-day and 49-day EMAs. Trade PYPL with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PYPL\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 6)\n        self.long_ema = self.EMA(self.symbol, 49)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 6 above EMA 49\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 6 below EMA 49\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between AAPL and MSFT using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"AAPL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"MSFT\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for PYPL with 20-period and 2.0 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PYPL\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 20, 2.0)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for INTC that buys when RSI < 22 and sells when RSI > 65. Use 20% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"INTC\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.2\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 22:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades BAC, CRM, META based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"BAC\", \"CRM\", \"META\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for GOOGL that buys when RSI < 26 and sells when RSI > 70. Use 20% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.2\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 26:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 70:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 5-day and 32-day SMAs. Trade PG with $500,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(500000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"PG\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 5)\n        self.long_sma = self.SMA(self.symbol, 32)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 5 crossed above SMA 32\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 5 crossed below SMA 32\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between GOOGL and META using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"GOOGL\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"META\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Build an RSI mean reversion strategy for QQQ that buys when RSI < 32 and sells when RSI > 76. Use 15% position sizing.",
    "response": "from AlgorithmImports import *\n\nclass RSIStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"QQQ\", Resolution.Daily).Symbol\n        \n        # Create RSI indicator\n        self.rsi = self.RSI(self.symbol, 14)\n        \n        # Position sizing\n        self.position_size = 0.15\n        \n    def OnData(self, data):\n        if not self.rsi.IsReady:\n            return\n            \n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: RSI oversold\n        if rsi_value < 32:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, self.position_size)\n                self.Log(f\"BUY: RSI oversold at {rsi_value:.2f}\")\n        \n        # Sell signal: RSI overbought\n        elif rsi_value > 76:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: RSI overbought at {rsi_value:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades SPY, WMT, PYPL based on 30-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"SPY\", \"WMT\", \"PYPL\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 30)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_30 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 30-day high\n            if price > high_30 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_30 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Build a pairs trading strategy between JPM and BAC using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"JPM\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"BAC\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for TSLA with 15-period and 1.5 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"TSLA\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 15, 1.5)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 11-day and 23-day EMAs. Trade WMT with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"WMT\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 11)\n        self.long_ema = self.EMA(self.symbol, 23)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 11 above EMA 23\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 11 below EMA 23\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 9-day and 45-day EMAs. Trade CSCO with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"CSCO\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 9)\n        self.long_ema = self.EMA(self.symbol, 45)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 9 above EMA 45\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 9 below EMA 45\")"
  },
  {
    "prompt": "Create a SMA crossover strategy using 12-day and 29-day SMAs. Trade ADBE with $50,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass SMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(50000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"ADBE\", Resolution.Daily).Symbol\n        \n        # Create moving averages\n        self.short_sma = self.SMA(self.symbol, 12)\n        self.long_sma = self.SMA(self.symbol, 29)\n        \n        # Track previous values for crossover detection\n        self.previous_short = 0\n        self.previous_long = 0\n        \n    def OnData(self, data):\n        if not (self.short_sma.IsReady and self.long_sma.IsReady):\n            return\n            \n        current_short = self.short_sma.Current.Value\n        current_long = self.long_sma.Current.Value\n        \n        # Check for crossover signals\n        if self.previous_short != 0 and self.previous_long != 0:\n            # Golden cross (buy signal)\n            if self.previous_short <= self.previous_long and current_short > current_long:\n                if not self.Portfolio[self.symbol].Invested:\n                    self.SetHoldings(self.symbol, 1.0)\n                    self.Log(f\"BUY: SMA 12 crossed above SMA 29\")\n            \n            # Death cross (sell signal)\n            elif self.previous_short >= self.previous_long and current_short < current_long:\n                if self.Portfolio[self.symbol].Invested:\n                    self.Liquidate(self.symbol)\n                    self.Log(f\"SELL: SMA 12 crossed below SMA 29\")\n        \n        self.previous_short = current_short\n        self.previous_long = current_long"
  },
  {
    "prompt": "Build a pairs trading strategy between KO and PEP using statistical arbitrage with z-score entry/exit signals.",
    "response": "from AlgorithmImports import *\nimport numpy as np\n\nclass PairsTradingStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add pairs\n        self.stock1 = self.AddEquity(\"KO\", Resolution.Daily).Symbol\n        self.stock2 = self.AddEquity(\"PEP\", Resolution.Daily).Symbol\n        \n        # Price history for spread calculation\n        self.lookback = 60\n        self.price_history1 = RollingWindow[float](self.lookback)\n        self.price_history2 = RollingWindow[float](self.lookback)\n        \n        # Trading parameters\n        self.entry_zscore = 2.0\n        self.exit_zscore = 0.0\n        self.in_position = False\n        \n    def OnData(self, data):\n        if self.stock1 in data and self.stock2 in data:\n            self.price_history1.Add(data[self.stock1].Close)\n            self.price_history2.Add(data[self.stock2].Close)\n            \n        if not (self.price_history1.IsReady and self.price_history2.IsReady):\n            return\n        \n        # Calculate spread and z-score\n        prices1 = np.array([x for x in self.price_history1])\n        prices2 = np.array([x for x in self.price_history2])\n        \n        # Simple hedge ratio calculation\n        hedge_ratio = np.mean(prices1) / np.mean(prices2)\n        spread = prices1 - hedge_ratio * prices2\n        spread_mean = np.mean(spread)\n        spread_std = np.std(spread)\n        \n        if spread_std == 0:\n            return\n        \n        current_spread = prices1[0] - hedge_ratio * prices2[0]\n        zscore = (current_spread - spread_mean) / spread_std\n        \n        # Trading logic\n        if not self.in_position:\n            if zscore < -self.entry_zscore:\n                # Long spread (buy stock1, sell stock2)\n                self.SetHoldings(self.stock1, 0.5)\n                self.SetHoldings(self.stock2, -0.5)\n                self.in_position = True\n                self.Log(f\"ENTER LONG SPREAD: Z-score {zscore:.2f}\")\n            elif zscore > self.entry_zscore:\n                # Short spread (sell stock1, buy stock2)\n                self.SetHoldings(self.stock1, -0.5)\n                self.SetHoldings(self.stock2, 0.5)\n                self.in_position = True\n                self.Log(f\"ENTER SHORT SPREAD: Z-score {zscore:.2f}\")\n        else:\n            if abs(zscore) <= self.exit_zscore:\n                self.Liquidate()\n                self.in_position = False\n                self.Log(f\"EXIT SPREAD: Z-score {zscore:.2f}\")"
  },
  {
    "prompt": "Create a Bollinger Bands mean reversion strategy for JNJ with 25-period and 2.0 standard deviations.",
    "response": "from AlgorithmImports import *\n\nclass BollingerBandsStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"JNJ\", Resolution.Daily).Symbol\n        \n        # Create Bollinger Bands\n        self.bb = self.BB(self.symbol, 25, 2.0)\n        self.rsi = self.RSI(self.symbol, 14)\n        \n    def OnData(self, data):\n        if not (self.bb.IsReady and self.rsi.IsReady):\n            return\n            \n        price = data[self.symbol].Close\n        upper_band = self.bb.UpperBand.Current.Value\n        lower_band = self.bb.LowerBand.Current.Value\n        rsi_value = self.rsi.Current.Value\n        \n        # Buy signal: Price near lower band and RSI oversold\n        if price <= lower_band * 1.01 and rsi_value < 35:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 0.5)\n                self.Log(f\"BUY: Price at lower BB band, RSI: {rsi_value:.2f}\")\n        \n        # Sell signal: Price near upper band and RSI overbought\n        elif price >= upper_band * 0.99 and rsi_value > 65:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: Price at upper BB band, RSI: {rsi_value:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades AAPL, CSCO, PYPL, AMZN, CRM, PG based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"AAPL\", \"CSCO\", \"PYPL\", \"AMZN\", \"CRM\", \"PG\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Design a momentum strategy that trades AMD, GOOGL, CSCO based on 50-day high breakouts with ATR-based position sizing.",
    "response": "from AlgorithmImports import *\n\nclass MomentumStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(100000)\n        \n        # Add equities\n        self.symbols = []\n        for ticker in [\"AMD\", \"GOOGL\", \"CSCO\"]:\n            symbol = self.AddEquity(ticker, Resolution.Daily).Symbol\n            self.symbols.append(symbol)\n        \n        # Create indicators for each symbol\n        self.highs = {}\n        self.atr = {}\n        \n        for symbol in self.symbols:\n            self.highs[symbol] = self.MAX(symbol, 50)\n            self.atr[symbol] = self.ATR(symbol, 14)\n        \n        # Risk parameters\n        self.risk_per_trade = 0.02\n        \n    def OnData(self, data):\n        for symbol in self.symbols:\n            if not (self.highs[symbol].IsReady and self.atr[symbol].IsReady):\n                continue\n                \n            if symbol not in data:\n                continue\n                \n            price = data[symbol].Close\n            high_50 = self.highs[symbol].Current.Value\n            atr_value = self.atr[symbol].Current.Value\n            \n            # Entry signal: Break above 50-day high\n            if price > high_50 and not self.Portfolio[symbol].Invested:\n                # Position sizing based on ATR\n                risk_amount = self.Portfolio.TotalPortfolioValue * self.risk_per_trade\n                position_size = min(risk_amount / (atr_value * 2), \n                                  self.Portfolio.TotalPortfolioValue * 0.1)\n                \n                if position_size > 0:\n                    self.SetHoldings(symbol, position_size / self.Portfolio.TotalPortfolioValue)\n                    self.Log(f\"BUY {symbol}: Breakout at {price:.2f}\")\n            \n            # Exit signal: Price falls below recent low (simple exit)\n            elif self.Portfolio[symbol].Invested and price < high_50 * 0.95:\n                self.Liquidate(symbol)\n                self.Log(f\"SELL {symbol}: Exit at {price:.2f}\")"
  },
  {
    "prompt": "Create a EMA crossover strategy using 14-day and 29-day EMAs. Trade INTC with $250,000 starting capital.",
    "response": "from AlgorithmImports import *\n\nclass EMAStrategy(QCAlgorithm):\n    \n    def Initialize(self):\n        self.SetStartDate(2020, 1, 1)\n        self.SetEndDate(2023, 12, 31)\n        self.SetCash(250000)\n        \n        # Add equity\n        self.symbol = self.AddEquity(\"INTC\", Resolution.Daily).Symbol\n        \n        # Create exponential moving averages\n        self.short_ema = self.EMA(self.symbol, 14)\n        self.long_ema = self.EMA(self.symbol, 29)\n        \n    def OnData(self, data):\n        if not (self.short_ema.IsReady and self.long_ema.IsReady):\n            return\n            \n        # Check for crossover signals\n        if self.short_ema.Current.Value > self.long_ema.Current.Value:\n            if not self.Portfolio[self.symbol].Invested:\n                self.SetHoldings(self.symbol, 1.0)\n                self.Log(f\"BUY: EMA 14 above EMA 29\")\n        else:\n            if self.Portfolio[self.symbol].Invested:\n                self.Liquidate(self.symbol)\n                self.Log(f\"SELL: EMA 14 below EMA 29\")"
  }
]